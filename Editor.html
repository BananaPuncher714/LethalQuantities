<DOCTYPE! html>
<html>
    <head>
        <title>Lethal Quantities Web Editor</title>
        <script>
            class BoundElement {
                constructor( element, obj ) {
                    this.data = obj;
                    this.element = element;
                    element.value = obj.value;
                    element.addEventListener( "change", event => {
                        switch ( event.type ) {
                            case "change": this.change( this.element.value );
                        }
                    }, false );
                }

                change( value ) {
                    this.data.value = value;
                    this.element.value = value;
                    this.data.set = !( this.element.value == null || this.element.value == "" );
                }

                getElement() {
                    return this.element;
                }
            }

            class ToggleableBoundElement extends BoundElement {
                constructor(input, obj) {
                    super(input, obj);

                    this.bar = document.createElement("span");
                    this.box = fromHtml(`<input type="checkbox">`);

                    this.box.addEventListener("change", event => {
                        switch (event.type) {
                            case "change": this.set();
                        }
                    }, false);

                    this.bar.appendChild(this.box);
                    this.bar.appendChild(this.element);

                    this.box.checked = obj.set;
                    this.set();
                }

                change(value) {
                    super.change(value);
                    this.set();
                }

                set() {
                    this.data.set = !(this.element.value == null || this.element.value == "") && this.box.checked;
                    this.element.disabled = !this.box.checked;
                }

                getElement() {
                    return this.bar;
                }
            }

            class BoundList {
                constructor( obj ) {
                    this.data = obj;

                    this.bar = document.createElement("span");
                    this.box = fromHtml( `<input type="checkbox">` );
                    this.container = fromHtml( `<div class="container"></div>` );

                    this.addButton = fromHtml( `<button>+</button>` )
                    this.addButton.onclick = () => this.addElement();

                    this.bar.appendChild( this.addButton );
                    this.container.appendChild( this.bar );
                    this.container.appendChild( document.createElement( "br" ) );

                    this.box.addEventListener( "change", event => {
                        switch ( event.type ) {
                            case "change": this.set( this.box.checked );
                        }
                    }, false );

                    const element = document.createElement( "span" );
                    element.appendChild( this.box );
                    element.appendChild( this.container );
                    this.element = element;

                    this.selectables = document.createElement( "div" );
                    this.container.appendChild( this.selectables );

                    this.set( obj.set );
                }

                set( value ) {
                    this.data.set = value;
                    this.container.style.display = value ? "" : "none";
                }

                getElement() {
                    return this.element;
                }

                removeElement(object) {
                    this.data.value.splice(this.data.value.findIndex(o => o === object), 1);
                }

                addElement(element, object) {
                    const row = document.createElement( "span" );
                    const deleteButton = fromHtml( `<button>X</button>` );
                    this.data.value.push(object);
                    deleteButton.onclick = () => {
                        this.removeElement(object);
                        this.selectables.removeChild( row );
                    };
                    row.appendChild(deleteButton);
                    if (element) {
                        row.appendChild(element);
                    }
                    row.appendChild( document.createElement( "br" ) );
                    this.selectables.appendChild( row );
                    
                    return row;
                }
            }

            class AnimationCurveBoundList extends BoundList {
                constructor( obj ) {
                    super( obj );

                    if (!obj.value) {
                        obj.value = [];
                    }
                    
                    let original = [...obj.value];
                    obj.value.length = 0;
                    for ( let i = 0; i < original.length; i++ ) {
                        this.addElement(null, original[i]);
                    }
                }

                addElement(element, frame = {value: null, time: null}) {
                    const span = document.createElement("span");
                    const time = fromHtml(`<input type="number" min=0></input>`);
                    time.value = frame.time;
                    time.addEventListener("change", event => {
                        switch (event.type) {
                            case "change": frame.time = time.value;
                        }
                    }, false);
                    const value = fromHtml(`<input type="number"></input>`);
                    value.value = frame.value;
                    value.addEventListener("change", event => {
                        switch (event.type) {
                            case "change": frame.value = value.value;
                        }
                    }, false);

                    span.appendChild(time);
                    span.appendChild(value);
                    if (element) {
                        span.appendChild(element);
                    }

                    return super.addElement(span, frame);
                }
            }

            class UniqueSelectBoundList extends BoundList {
                constructor( obj, options ) {
                    super( obj );

                    this.options = options;
                    // Map of all available options
                    this.selectOptions = {};
                    // Map of added nodes
                    this.availableContainers = {};
                    // Array of removed options
                    this.filtered = [];
                    // Map of spoilers to open and close
                    this.spoilers = {};
                    this.headers = {};

                    if (!obj.value) {
                        obj.value = [];
                    }

                    const addSelect = fromHtml(`<select style="min-width:100px;max-width:250px;"></select>`);
                    for (const [key, value] of Object.entries(options)) {
                        const optionEl = fromHtml(`<option value="${key}">${value.name}</option>`);
                        addToSelect(addSelect, optionEl);
                        this.selectOptions[key] = optionEl;
                    }
                    this.bar.appendChild(addSelect);

                    this.searchBar = fromHtml(`<input type="search">`);
                    this.searchBar.addEventListener("input", e => {
                        switch (e.type) {
                            case "input": this.updateSearch();
                        }
                    }, false);
                    this.bar.appendChild(this.searchBar);
                    this.selected = addSelect;

                    this.bar.appendChild(document.createElement("br"));
                    const showAll = fromHtml(`<button>Show All</button>`);
                    showAll.onclick = () => {
                        for (const [key, spoiler] of Object.entries(this.spoilers)) {
                            if (this.availableContainers[key].style.display !== "none") {
                                spoiler.setOpen(true);
                            }
                        }
                    };
                    const hideAll = fromHtml(`<button>Hide All</button>`);
                    hideAll.onclick = () => {
                        for (const [key, spoiler] of Object.entries(this.spoilers)) {
                            if (this.availableContainers[key].style.display !== "none") {
                                spoiler.setOpen(false);
                            }
                        }
                    };
                    this.bar.appendChild(showAll);
                    this.bar.appendChild(hideAll);

                    let original = [...obj.value];
                    obj.value.length = 0;
                    for (let i = 0; i < original.length; i++) {
                        addElement(null, original[i].id);
                    }

                    const containsAny = this.selected.children.length > 0;
                    this.selected.disabled = !containsAny;
                    this.addButton.disabled = !containsAny;
                }

                updateSearch() {
                    const search = this.searchBar.value.toLowerCase().replace(/\s/g, '');
                    if (search == null || search == "") {
                        // Reset all filtered options
                        for (const val of Object.values(this.availableContainers)) {
                            val.style.display = "";
                        }
                        for (let i = 0; i < this.filtered.length; i++) {
                            addToSelect(this.selected, this.filtered[i]);
                        }
                        this.filtered.length = 0;
                    } else {
                        // Get ones that need to be added
                        const add = []
                        for (let i = this.filtered.length - 1; i >= 0; i--) {
                            const option = this.filtered[i];
                            const label = option.label.toLowerCase().replace(/\s/g, '');
                            const value = option.value.toLowerCase().replace(/\s/g, '');
                            if (label.includes(search) || value.includes(search)) {
                                add.push(option);
                                this.filtered.splice(i, 1);
                            }
                        }
                        
                        // Get ones that need to be removed
                        const remove = [];
                        for (let i = 0; i < this.selected.children.length; i++) {
                            const option = this.selected.children[i];
                            const label = option.label.toLowerCase().replace(/\s/g, '');
                            const value = option.value.toLowerCase().replace(/\s/g, '');
                            if (!(label.includes(search) || value.includes(search))) {
                                remove.push(option);
                                this.filtered.push(option);
                            }
                        }

                        // Make changes here, to prevent iterating over some options multiple times
                        for (let i = 0; i < remove.length; i++) {
                            this.selected.removeChild(remove[i]);
                        }
                        for (let i = 0; i < add.length; i++) {
                            addToSelect(this.selected, add[i]);
                        }

                        // Filter all added objects
                        for (const [key, val] of Object.entries(this.availableContainers)) {
                            const option = this.options[key];
                            const id = option.id?.toLowerCase().replace(/\s/g, '');
                            const name= option.name?.toLowerCase().replace(/\s/g, '');
                            if (id?.includes(search) || name?.includes(search)) {
                                val.style.display = "";
                            } else {
                                val.style.display = "none";
                            }
                        }
                    }

                    const containsAny = this.selected.children.length > 0;
                    this.selected.disabled = !containsAny;
                    this.addButton.disabled = !containsAny;
                }

                removeElement(object) {
                    addToSelect(this.selected, this.selectOptions[object.id]);
                    this.updateSearch();

                    // TODO Should consolidate this into one object
                    delete this.availableContainers[object.id];
                    delete this.spoilers[object.id];
                    delete this.headers[object.id];

                    super.removeElement(object);
                }

                addElement(element, id = this.selected.value) {
                    let obj = cloneInstance(this.options[id]);
                    this.selected.removeChild(this.selectOptions[id]);
                    if (this.selected.children.length == 0) {
                        this.selected.disabled = true;
                        this.addButton.disabled = true;
                    }

                    const bound = fromHtml(`<span><br></span>`)
                    bound.appendChild(obj.bind());
                    const header = fromHtml(`<span><span style="width:200px;display:inline-block;text-overflow:ellipsis;overflow:hidden;white-space:nowrap;">${obj.name}</span></span>`)
                    const spoiler = new SpoilerElement(bound, header);

                    const superEl = super.addElement(spoiler.getElement(), obj);

                    // Add to added options
                    this.availableContainers[id] = superEl;
                    this.spoilers[id] = spoiler;
                    this.headers[id] = header;

                    return superEl;
                }
            }

            class UniqueRarityBoundList extends UniqueSelectBoundList {
                constructor( obj, options ) {
                    super( obj, options );
                }

                removeElement(object) {
                    super.removeElement(object);
                }

                addElement(element, id = this.selected.value) {
                    const el = super.addElement(element, id);

                    this.headers[id].appendChild(fromHtml(`<span>Rarity</span>`));
                    this.headers[id].appendChild(bindToggleableInt(this.options[id].rarity, "50px"));

                    return el;
                }
            }

            class SpoilerElement {
                constructor(element, after = null) {
                    const span = document.createElement("span");

                    const setting = { display: "", open: true };
                    const box = fromHtml(`<button>H</button>`);
                    box.onclick = () => {
                        this.setOpen(!this.setting.open);
                    };

                    span.appendChild(box);
                    if (after) {
                        span.appendChild(after);
                    }
                    span.appendChild(element);

                    this.inner = element;
                    this.setting = setting;
                    this.box = box;
                    this.el = span;
                }

                getElement() {
                    return this.el;
                }

                setOpen(option) {
                    if (option) {
                        this.inner.style.display = this.setting.display;
                        this.box.textContent = "H";
                    } else {
                        if (this.setting.open) {
                            this.setting.display = this.inner.style.display;
                        }
                        this.inner.style.display = "none";
                        this.box.textContent = "S";
                    }
                    this.setting.open = option;
                }
            }

            function cloneInstance(obj) {
                return Object.assign(Object.create(Object.getPrototypeOf(obj)), structuredClone(obj));
            }

            function getPOLO() {
                return {
                    value: null,
                    set: false
                };
            }

            class EnemyType {
                constructor() {
                    this.maxEnemyCount = getPOLO();
                    this.powerLevel = getPOLO();
                    this.spawnChanceCurve = getPOLO();
                    this.stunTimeMultiplier = getPOLO();
                    this.doorSpeedMultiplier = getPOLO();
                    this.stunGameDifficultyMultiplier = getPOLO();
                    this.stunnable = getPOLO();
                    this.killable = getPOLO();
                    this.enemyHp = getPOLO();
                    this.spawnFalloffCurve = getPOLO();
                    this.useSpawnFalloff = getPOLO();
                    this.rarity = getPOLO();
                    this.name = "";
                    this.id = "";
                }

                bind() {
                    const container = containerNode.cloneNode(true);
                    addEntry(container, "Max enemy count", bindToggleableUnsignedInt(this.maxEnemyCount));
                    addEntry(container, "Power level", bindToggleableUnsignedInt(this.powerLevel));
                    addEntry(container, "Spawn chance curve", new AnimationCurveBoundList(this.spawnChanceCurve).getElement());
                    addEntry(container, "Stun time multiplier", bindToggleableUnsignedFloat(this.stunTimeMultiplier));
                    addEntry(container, "Door speed multiplier", bindToggleableUnsignedFloat(this.doorSpeedMultiplier));
                    addEntry(container, "Stun game difficulty multiplier", bindToggleableUnsignedFloat(this.stunGameDifficultyMultiplier));
                    addEntry(container, "Stunnable", bindToggleableBool(this.stunnable));
                    addEntry(container, "Killable", bindToggleableBool(this.killable));
                    addEntry(container, "Enemy HP", bindToggleableUnsignedInt(this.enemyHp));
                    addEntry(container, "Spawn falloff curve", new AnimationCurveBoundList(this.spawnFalloffCurve).getElement());
                    addEntry(container, "Use spawn falloff curve", bindToggleableBool(this.useSpawnFalloff));
                    return container;
                }
            }

            class ItemType {
                constructor() {
                    this.weight = getPOLO();
                    this.minValue = getPOLO();
                    this.maxValue = getPOLO();
                    this.conductive = getPOLO();
                    this.rarity = getPOLO();
                    this.scrap = true;
                    this.name = "";
                    this.id = "";
                }

                bind(includeWeight = false) {
                    const container = containerNode.cloneNode(true);
                    if (this.scrap) {
                        addEntry(container, "Min value", bindToggleableUnsignedInt(this.minValue));
                        addEntry(container, "Max value", bindToggleableUnsignedInt(this.maxValue));
                    }
                    if (includeWeight) {
                        addEntry(container, "Weight", bindToggleableUnsignedFloat(this.weight));
                    }
                    addEntry(container, "Conductive", bindToggleableBool(this.conductive));
                    return container;
                }
            }

            const containerNode = fromHtml('<div class="container"></div>');

            function fromHtml(html) {
                const template = document.createElement("template");
                template.innerHTML = html;
                const result = template.content.children;
                return result.length === 1 ? result[0] : result;
            }

            function addEntry(block, title, element) {
                const span = document.createElement("span");
                span.appendChild(fromHtml(`<span class="title">${title}</span>`));
                span.appendChild(element);
                span.appendChild(document.createElement("br"));
                block.appendChild(span);
            }

            const animationCurve = {
                value: [{
                    time: 0,
                    value: -3
                }],
                set: false
            }

            var defaultData = null;

            function selectFile(event) {
                let file = event.target.files[0];
                let reader = new FileReader();
                reader.onload = file => {
                    defaultData = JSON.parse(reader.result);
                    console.log(defaultData);

                    addEntry(document.getElementById("subcontainer"), "Enemies", new UniqueRarityBoundList({
                        value: [],
                        set: false
                    }, generateEnemyTypes()).getElement());
                    addEntry(document.getElementById("subcontainer"), "Items", new UniqueRarityBoundList({
                        value: [],
                        set: false
                    }, generateItemTypes()).getElement());
                };
                reader.readAsText(file);
            }

            function generateEnemyTypes() {
                let types = {};
                for (const [id, type] of Object.entries(defaultData.enemies)) {
                    let jsType = new EnemyType();

                    jsType.maxEnemyCount.value = type.max_enemy_count;
                    jsType.powerLevel.value = type.power_level;
                    jsType.spawnChanceCurve.value = type.spawn_chance_curve;
                    jsType.stunTimeMultiplier.value = type.stun_time_multiplier;
                    jsType.doorSpeedMultiplier.value = type.door_speed_multiplier;
                    jsType.stunGameDifficultyMultiplier.value = type.stun_game_difficulty_multiplier;
                    jsType.stunnable.value = type.stunnable;
                    jsType.killable.value = type.killable;
                    jsType.enemyHp.value = type.enemy_hp;
                    jsType.spawnFalloffCurve.value = type.spawn_falloff_curve;
                    jsType.useSpawnFalloff.value = type.use_spawn_falloff;
                    jsType.name = type.name == null ? id : type.name;
                    jsType.id = id;

                    types[id] = jsType;
                }
                return types;
            }

            function generateItemTypes() {
                let types = {};
                for (const [id, type] of Object.entries(defaultData.items)) {
                    let jsType = new ItemType();

                    jsType.weight.value = type.weight;
                    // TODO Change it from minValue to min_value, etc
                    jsType.minValue.value = type.min_value;
                    jsType.maxValue.value = type.max_value;
                    jsType.conductive.value = type.conductive;
                    jsType.scrap = type.scrap;
                    jsType.name = type.name;
                    jsType.id = id;

                    types[id] = jsType;
                }
                return types;
            }

            function doStuff() {
                const element = fromHtml('<input type="text">');
                const data = {
                    value: null,
                    set: false
                };

                const optional = {
                    value: "",
                    set: false
                };

                const listData = {
                    value: [],
                    set: false
                }

                addEntry(document.getElementById("subcontainer"), "Test", bindInt(data));
                addEntry(document.getElementById("subcontainer"), "Test2", bindBool(optional));
                addEntry(document.getElementById("subcontainer"), "Test2", bindList(listData));
                addEntry(document.getElementById("subcontainer"), "Test2", new AnimationCurveBoundList(animationCurve).getElement());
                addEntry(document.getElementById("subcontainer"), "Test enemy type", new SpoilerElement(new EnemyType().bind()).getElement());
                addEntry(document.getElementById("subcontainer"), "Test item", new SpoilerElement(new ItemType().bind()).getElement());
            }

            function addStuff() {
                const element = document.getElementById("data").cloneNode(true);
                addEntry(document.getElementById("subcontainer"), "Test", element);
            }

            function loadPreset(preset) {
                const root = containerNode.cloneNode(true);
                // Create bound data, etc
                // Add to root accordingly
                // Add to lists with new function
                // How to bind data efficiently?
                
            }

            function bindToggleableInt(obj, width = "") {
                return new ToggleableBoundElement(fromHtml(`<input type="number" step="1" style="width:${width};">`), obj).getElement();
            }

            function bindToggleableUnsignedInt(obj, width = "") {
                return new ToggleableBoundElement(fromHtml(`<input type="number" min=0 step=1 style="width:${width};">`), obj).getElement();
            }

            function bindInt(obj, width = "") {
                return new BoundElement(fromHtml(`<input type="number" step="1" style="width:${width};">`), obj).getElement();
            }

            function bindToggleableFloat(obj, width = "") {
                return new ToggleableBoundElement(fromHtml(`<input type="number" style="width:${width};">`), obj).getElement();
            }

            function bindToggleableUnsignedFloat(obj, width = "") {
                return new ToggleableBoundElement(fromHtml(`<input type="number" min=1 style="width:${width};">`), obj).getElement();
            }

            function bindFloat(obj, width = "") {
                return new BoundElement(fromHtml(`<input type="number" style="width:${width};">`), obj).getElement();
            }

            function bindToggleableBool(obj) {
                const select = fromHtml(`<select>
                <option value=true>True</option>
                <option value=false>False</option>
                </select>`);
                return new ToggleableBoundElement(select, obj).getElement();
            }

            function bindBool(obj) {
                const select = fromHtml(`<select>
                <option value=null></option>
                <option value=true>True</option>
                <option value=false>False</option>
                </select>`);
                return new BoundElement(select, obj).getElement();
            }

            function bindList(obj) {
                return new BoundList(obj).getElement();
            }

            // Insertion sort
            function addToSelect(sel, el) {
                let index = 0;
                for (; index < sel.options.length && el.text > sel.options[index].text; index++);
                if (index == sel.options.length) {
                    sel.options.add(el);
                } else {
                    sel.options.add(el, sel.options[index]);
                }
            }
        </script>
        <style>
            div.editor {
                display: block;
            }
            div.container {
                vertical-align: text-top;
                outline-style: solid;
                border-radius: 2px;
                padding: 5px;
                margin: 5px;
                display: inline-block;
            }
            span.title {
                display: inline-block;
                margin-top: 5px;
                width: 200px;
                text-align: right;
            }
        </style>
    </head>
    <body>
        <input type="file" onchange="selectFile(event)">
        <button onclick="doStuff()">Do stuff</button>
        <button onclick="addStuff()">Add stuff</button>
        <div class="editor" id="editor">
            <div class="container" id="subcontainer">
            </div>
            <span class="title">More Data</span>
            <div class="container" id="data">
                Some more content here
                <div class="container">Additional stuff here</div>
            </div>
        </div>
    </body>
</html>