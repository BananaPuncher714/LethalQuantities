<DOCTYPE! html>
<html>
    <head>
        <title>Lethal Quantities Web Editor</title>
        <script>
            class BoundElement {
                constructor( element, obj ) {
                    this.data = obj;
                    this.element = element;
                    element.value = obj.value;
                    element.addEventListener( "change", event => {
                        switch ( event.type ) {
                            case "change": this.change( this.element.value );
                        }
                    }, false );
                }

                change( value ) {
                    let different = this.data.value != value;
                    this.data.value = value;
                    this.element.value = value;
                    this.data.set = !( this.element.value == null || this.element.value == "" );
                    if (different) {
                        this.data.onchange?.();
                    }
                }

                getElement() {
                    return this.element;
                }
            }

            class ToggleableBoundElement extends BoundElement {
                constructor(input, obj) {
                    super(input, obj);

                    this.bar = document.createElement("span");
                    this.box = fromHtml(`<input type="checkbox">`);

                    this.box.addEventListener("change", event => {
                        switch (event.type) {
                            case "change": this.set();
                        }
                    }, false);

                    this.bar.appendChild(this.box);
                    this.bar.appendChild(this.element);

                    this.box.checked = obj.set;
                    this.set();
                }

                change(value) {
                    super.change(value);
                    this.set();
                }

                set() {
                    this.data.set = !(this.element.value == null || this.element.value == "") && this.box.checked;
                    this.element.disabled = !this.box.checked;
                }

                getElement() {
                    return this.bar;
                }
            }

            class BoundList {
                constructor( obj ) {
                    this.data = obj;

                    // Map object to html node
                    this.objectRows = new Map();
                    this.bar = document.createElement("span");
                    this.box = fromHtml( `<input type="checkbox">` );
                    this.container = fromHtml( `<div class="container"></div>` );
                    this.spoilered = new SpoilerElement(obj, this.container).getElement();

                    this.addButton = fromHtml( `<button>+</button>` )
                    this.addButton.onclick = () => this.addElement();

                    this.bar.appendChild( this.addButton );
                    this.container.appendChild( this.bar );
                    this.container.appendChild( document.createElement( "br" ) );

                    this.box.addEventListener( "change", event => {
                        switch ( event.type ) {
                            case "change": this.set( this.box.checked );
                        }
                    }, false );

                    const element = document.createElement( "span" );
                    element.appendChild( this.box );
                    element.appendChild( this.spoilered );
                    this.element = element;

                    this.selectables = document.createElement( "div" );
                    this.container.appendChild( this.selectables );

                    this.set( obj.set );
                }

                set( value ) {
                    this.box.checked = value;
                    this.data.set = value;
                    this.spoilered.style.display = value ? "" : "none";
                }

                getElement() {
                    return this.element;
                }

                removeElement(object) {
                    this.data.value.splice(this.data.value.findIndex(o => o === object), 1);
                    this.data.onremove?.(object);
                    this.selectables.removeChild(this.objectRows.get(object));
                    this.objectRows.delete(object);
                }

                addElement(element, object) {
                    const row = document.createElement( "span" );
                    const deleteButton = fromHtml( `<button>X</button>` );
                    this.data.value.push(object);
                    this.data.onadd?.(object);
                    deleteButton.onclick = () => {
                        this.removeElement(object);
                    };
                    row.appendChild(deleteButton);
                    if (element) {
                        row.appendChild(element);
                    }
                    row.appendChild( document.createElement( "br" ) );
                    this.selectables.appendChild( row );

                    this.objectRows.set(object, row);
                    
                    return row;
                }
            }

            class AnimationCurveBoundList extends BoundList {
                constructor( obj ) {
                    super( obj );

                    if (!obj.value) {
                        obj.value = [];
                    }
                    
                    let original = [...obj.value];
                    obj.value.length = 0;
                    for ( let i = 0; i < original.length; i++ ) {
                        this.addElement(null, original[i]);
                    }

                    this.bar.appendChild(fromHtml(`<span style="width:100px;display:inline-block;">Key</span>`));
                    this.bar.appendChild(fromHtml(`<span>Value</span>`));
                }

                addElement(element, frame = {value: null, time: null}) {
                    const span = document.createElement("span");
                    const time = fromHtml(`<input type="number" min=0 style="width:100px;"></input>`);
                    time.value = frame.time;
                    time.addEventListener("change", event => {
                        switch (event.type) {
                            case "change": frame.time = time.value;
                        }
                    }, false);
                    const value = fromHtml(`<input type="number" style="width:100px;"></input>`);
                    value.value = frame.value;
                    value.addEventListener("change", event => {
                        switch (event.type) {
                            case "change": frame.value = value.value;
                        }
                    }, false);

                    span.appendChild(time);
                    span.appendChild(value);
                    if (element) {
                        span.appendChild(element);
                    }

                    return super.addElement(span, frame);
                }
            }

            class UniqueSelectBoundList extends BoundList {
                constructor( obj, options, binder ) {
                    super( obj );

                    this.options = options;
                    // Map of all available options
                    this.selectOptions = {};
                    // Map of added nodes
                    this.availableContainers = {};
                    // Array of removed options
                    this.filtered = [];
                    // Map of spoilers to open and close
                    this.spoilers = {};
                    this.headers = {};

                    // Binds the given object and returns a DOM element
                    this.binder = binder;

                    if (!obj.value) {
                        obj.value = [];
                    }

                    const addSelect = fromHtml(`<select style="min-width:200px;max-width:200px;"></select>`);
                    for (const [key, value] of Object.entries(options)) {
                        const optionEl = fromHtml(`<option value="${key}">${value.name}</option>`);
                        addToSelect(addSelect, optionEl);
                        this.selectOptions[key] = optionEl;
                    }
                    this.bar.appendChild(addSelect);

                    this.searchBar = fromHtml(`<input type="search">`);
                    this.searchBar.addEventListener("input", e => {
                        switch (e.type) {
                            case "input": this.updateSearch();
                        }
                    }, false);
                    this.bar.appendChild(this.searchBar);
                    this.selected = addSelect;

                    this.bar.appendChild(document.createElement("br"));
                    const showAll = fromHtml(`<button>Show All</button>`);
                    showAll.onclick = () => {
                        for (const [key, spoiler] of Object.entries(this.spoilers)) {
                            if (this.availableContainers[key].style.display !== "none") {
                                spoiler.setOpen(true);
                            }
                        }
                    };
                    const hideAll = fromHtml(`<button>Hide All</button>`);
                    hideAll.onclick = () => {
                        for (const [key, spoiler] of Object.entries(this.spoilers)) {
                            if (this.availableContainers[key].style.display !== "none") {
                                spoiler.setOpen(false);
                            }
                        }
                    };
                    const addAll = fromHtml(`<button>Add All</button>`);
                    addAll.onclick = () => {
                        while (this.selected.children.length > 0) {
                            this.addElement();
                        }
                    };
                    const removeAll = fromHtml(`<button>Remove All</button>`);
                    removeAll.onclick = () => {
                        for (const [key, value] of Object.entries(this.availableContainers)) {
                            if (value.style.display !== "none") {
                                this.removeElement(this.options[key]);
                            }
                        }
                    };
                    this.bar.appendChild(showAll);
                    this.bar.appendChild(hideAll);
                    this.bar.appendChild(addAll);
                    this.bar.appendChild(removeAll);

                    let original = [...obj.value];
                    obj.value.length = 0;
                    for (let i = 0; i < original.length; i++) {
                        this.addElement(null, original[i]);
                    }

                    const containsAny = this.selected.children.length > 0;
                    this.selected.disabled = !containsAny;
                    this.addButton.disabled = !containsAny;
                }

                updateSearch() {
                    const search = this.searchBar.value.toLowerCase().replace(/\s/g, '');
                    if (search == null || search == "") {
                        // Reset all filtered options
                        for (const [id, val] of Object.entries(this.availableContainers)) {
                            if (!this.isFiltered(id)) {
                                val.style.display = "";
                            } else {
                                val.style.display = "none";
                            }
                        }
                        for (let i = 0; i < this.filtered.length; i++) {
                            addToSelect(this.selected, this.filtered[i]);
                        }
                        this.filtered.length = 0;
                    } else {
                        // Get ones that need to be added
                        const add = []
                        for (let i = this.filtered.length - 1; i >= 0; i--) {
                            const option = this.filtered[i];
                            const label = option.label.toLowerCase().replace(/\s/g, '');
                            const value = option.value.toLowerCase().replace(/\s/g, '');
                            if (label.includes(search) || value.includes(search)) {
                                add.push(option);
                                this.filtered.splice(i, 1);
                            }
                        }
                        
                        // Get ones that need to be removed
                        const remove = [];
                        for (let i = 0; i < this.selected.children.length; i++) {
                            const option = this.selected.children[i];
                            const label = option.label.toLowerCase().replace(/\s/g, '');
                            const value = option.value.toLowerCase().replace(/\s/g, '');
                            if (!(label.includes(search) || value.includes(search))) {
                                remove.push(option);
                                this.filtered.push(option);
                            }
                        }

                        // Make changes here, to prevent iterating over some options multiple times
                        for (let i = 0; i < remove.length; i++) {
                            this.selected.removeChild(remove[i]);
                        }
                        for (let i = 0; i < add.length; i++) {
                            addToSelect(this.selected, add[i]);
                        }

                        // Filter all added objects
                        for (const [key, val] of Object.entries(this.availableContainers)) {
                            const option = this.options[key];
                            const id = option.id?.toLowerCase().replace(/\s/g, '');
                            const name = option.name?.toLowerCase().replace(/\s/g, '');
                            if ((id?.includes(search) || name?.includes(search)) && !this.isFiltered(key)) {
                                val.style.display = "";
                            } else {
                                val.style.display = "none";
                            }
                        }
                    }

                    const containsAny = this.selected.children.length > 0;
                    this.selected.disabled = !containsAny;
                    this.addButton.disabled = !containsAny;
                }

                isFiltered(key) {
                    return false;
                }

                removeElement(object) {
                    addToSelect(this.selected, this.selectOptions[object.id]);
                    this.updateSearch();

                    // TODO Should consolidate this into one object
                    delete this.availableContainers[object.id];
                    delete this.spoilers[object.id];
                    delete this.headers[object.id];

                    super.removeElement(object);
                }

                addElement(element, object) {
                    // Should element be used?
                    // Could clone if the data should be reset when re-added
                    if (object) {
                        // Set the current option to the provided object, if not null
                        this.options[object.id] = object;
                    } else {
                        // Get the object if not null
                        object = this.options[this.selected.value];
                    }
                    const id = object.id;
                    this.selected.removeChild(this.selectOptions[id]);
                    if (this.selected.children.length == 0) {
                        this.selected.disabled = true;
                        this.addButton.disabled = true;
                    }

                    const header = fromHtml(`<span><span style="width:200px;display:inline-block;text-overflow:ellipsis;overflow:hidden;white-space:nowrap;">${object.name}</span></span>`);
                    const spoiler = new BindableSpoilerElement(object, header, this.binder);

                    const superEl = super.addElement(spoiler.getElement(), object);

                    // Add to added options
                    this.availableContainers[id] = superEl;
                    this.spoilers[id] = spoiler;
                    this.headers[id] = header;

                    if (!this.isFiltered(id)) {
                        superEl.style.display = "";
                    } else {
                        superEl.style.display = "none";
                    }

                    return superEl;
                }
            }

            class UniqueRarityBoundList extends UniqueSelectBoundList {
                constructor( obj, options, binder ) {
                    super( obj, options, binder );

                    const span = fromHtml(`<span><br><span>Display</span>`);
                    this.raritySelect = fromHtml(`<select>
                    <option value="none">All</option>
                    <option value="selected">Selected</option>
                    <option value="deselected">Deselected</option>
                    </select>`);
                    this.raritySelect.addEventListener("change", event => {
                        switch (event.type) {
                            case "change": this.updateSearch();
                        }
                    }, false);
                    span.appendChild(this.raritySelect);
                    this.bar.appendChild(span);
                }

                removeElement(object) {
                    super.removeElement(object);
                }

                isFiltered(key) {
                    if (!this.raritySelect) {
                        return super.isFiltered(key);
                    }

                    const rarity = this.options[key].rarity;
                    switch (this.raritySelect.value) {
                        case "deselected":
                            return rarity.set || rarity.value === 0;
                        case "selected":
                            return (!rarity.set || rarity.value === 0)
                        default:
                            return super.isFiltered(key);
                    }
                }

                addElement(element, object) {
                    const id = object ? object.id : this.selected.value;
                    const el = super.addElement(element, object);
                    const obj = this.options[id];

                    this.headers[id].appendChild(fromHtml(`<span>Rarity</span>`));
                    this.headers[id].appendChild(bindToggleableInt(obj.rarity, "50px"));
                    // TODO Add some lock to make the value modifiable or not
                    // Or, something like that at least
                    // Include a percentage, and slider
                    // What to do if the inherited preset has values, but are not used?
                    // TODO Use placeholders for some values?
                    // TODO How to get parent value?

                    return el;
                }
            }

            // Kind of a redundant class, can be replaced with summary
            class SpoilerElement {
                constructor(obj, element, after = null) {
                    const span = document.createElement("span");

                    const hidden = obj.hidden;
                    const setting = { display: "", open: hidden };
                    const box = fromHtml(`<button>H</button>`);
                    box.onclick = () => {
                        this.setOpen(!this.setting.open);
                    };

                    span.appendChild(box);
                    if (after) {
                        span.appendChild(after);
                    }

                    const extra = fromHtml(`<span><br><span class="title"></span></span>`);
                    extra.appendChild(element);
                    span.appendChild(extra);

                    this.object = obj;
                    this.inner = extra;
                    this.setting = setting;
                    this.box = box;
                    this.el = span;

                    this.setOpen(!hidden);
                }

                getElement() {
                    return this.el;
                }

                setOpen(option) {
                    if (option) {
                        this.inner.style.display = this.setting.display;
                        this.box.textContent = "H";
                    } else {
                        if (this.setting.open) {
                            this.setting.display = this.inner.style.display;
                        }
                        this.inner.style.display = "none";
                        this.box.textContent = "S";
                    }
                    this.object.hidden = !option;
                    this.setting.open = option;
                }
            }

            class BindableSpoilerElement {
                constructor(bindableElement, after = null, binder) {
                    const span = document.createElement("span");

                    const hidden = bindableElement.hidden;
                    const setting = { display: "", open: hidden };
                    const box = fromHtml(`<button>H</button>`);
                    box.onclick = () => {
                        this.setOpen(!this.setting.open);
                    };

                    span.appendChild(box);
                    if (after) {
                        span.appendChild(after);
                    }

                    this.binder = binder;
                    this.inner = bindableElement;
                    this.setting = setting;
                    this.box = box;
                    this.el = span;

                    this.setOpen(!hidden);
                }

                getElement() {
                    return this.el;
                }

                setOpen(option) {
                    if (option) {
                        if (!this.setting.open) {
                            this.boundNode = fromHtml(`<span><br><span class="title"></span>`);
                            this.boundNode.appendChild(this.binder(this.inner));
                            this.el.appendChild(this.boundNode);
                            this.box.textContent = "H";
                        }
                    } else {
                        if (this.boundNode) {
                            this.el.removeChild(this.boundNode);
                        }
                        this.boundNode = null;
                        this.box.textContent = "S";
                    }
                    this.inner.hidden = !option;
                    this.setting.open = option;
                }
            }

            // Plain old lethal object
            // Better than plain old optional object
            function getPOLO() {
                return {
                    value: null,
                    set: false
                };
            }

            class EnemyType {
                constructor() {
                    this.maxEnemyCount = getPOLO();
                    this.powerLevel = getPOLO();
                    this.spawnChanceCurve = getPOLO();
                    this.stunTimeMultiplier = getPOLO();
                    this.doorSpeedMultiplier = getPOLO();
                    this.stunGameDifficultyMultiplier = getPOLO();
                    this.stunnable = getPOLO();
                    this.killable = getPOLO();
                    this.enemyHp = getPOLO();
                    this.spawnFalloffCurve = getPOLO();
                    this.useSpawnFalloff = getPOLO();
                    this.rarity = getPOLO();
                    this.hasSpawnFalloff = true;
                    this.name = "";
                    this.id = "";
                }

                static bind(enemy) {
                    const container = containerNode.cloneNode(true);
                    addEntry(container, "Max enemy count", bindToggleableUnsignedInt(enemy.maxEnemyCount));
                    addEntry(container, "Power level", bindToggleableUnsignedInt(enemy.powerLevel));
                    addEntry(container, "Spawn chance curve", new AnimationCurveBoundList(enemy.spawnChanceCurve).getElement());
                    addEntry(container, "Stun time multiplier", bindToggleableUnsignedFloat(enemy.stunTimeMultiplier));
                    addEntry(container, "Door speed multiplier", bindToggleableUnsignedFloat(enemy.doorSpeedMultiplier));
                    addEntry(container, "Stun game difficulty multiplier", bindToggleableUnsignedFloat(enemy.stunGameDifficultyMultiplier));
                    addEntry(container, "Stunnable", bindToggleableBool(enemy.stunnable));
                    addEntry(container, "Killable", bindToggleableBool(enemy.killable));
                    addEntry(container, "Enemy HP", bindToggleableUnsignedInt(enemy.enemyHp));
                    if (enemy.hasSpawnFalloff) {
                        addEntry(container, "Spawn falloff curve", new AnimationCurveBoundList(enemy.spawnFalloffCurve).getElement());
                        addEntry(container, "Use spawn falloff curve", bindToggleableBool(enemy.useSpawnFalloff));
                    }
                    return container;
                }
            }

            class ItemType {
                constructor() {
                    this.weight = getPOLO();
                    this.minValue = getPOLO();
                    this.maxValue = getPOLO();
                    this.conductive = getPOLO();
                    this.rarity = getPOLO();
                    this.scrap = true;
                    this.name = "";
                    this.id = "";
                }

                static bind(item, includeWeight = false) {
                    const container = containerNode.cloneNode(true);
                    if (item.scrap) {
                        addEntry(container, "Min value", bindToggleableUnsignedInt(item.minValue));
                        addEntry(container, "Max value", bindToggleableUnsignedInt(item.maxValue));
                    }
                    if (includeWeight) {
                        addEntry(container, "Weight", bindToggleableUnsignedFloat(item.weight));
                    }
                    addEntry(container, "Conductive", bindToggleableBool(item.conductive));
                    return container;
                }
            }

            class TrapType {
                constructor() {
                    this.spawnCurve = getPOLO();
                    this.spawnFacingAwayFromWall = false;
                    this.name = "";
                    this.id = "";
                }

                static bind(trap) {
                    const container = containerNode.cloneNode(true);
                    addEntry(container, "Spawn curve", new AnimationCurveBoundList(trap.spawnCurve).getElement());
                    return container;
                }
            }

            class DungeonFlowType {
                constructor() {
                    this.factorySizeMultiplier = getPOLO();
                    this.rarity = getPOLO();
                    this.name = "";
                    this.id = "";
                }

                static bind(flow) {
                    const container = containerNode.cloneNode(true);
                    addEntry(container, "Factory size multiplier", new bindToggleableUnsignedFloat(flow.factorySizeMultiplier));
                    return container;
                }
            }

            class PriceType {
                constructor() {
                    this.price = getPOLO();
                    this.name = "";
                    this.id = "";
                }

                static bind(price) {
                    const container = containerNode.cloneNode(true);
                    addEntry(container, "Price", new bindToggleableUnsignedInt(price.price));
                    return container;
                }
            }

            class Preset {
                constructor() {
                    this.mapSizeMultiplier = getPOLO();
                    this.scrapAmountMultiplier = getPOLO();
                    this.scrapValueMultiplier = getPOLO();
                    this.minScrap = getPOLO();
                    this.maxScrap = getPOLO();
                    this.maxPowerCount = getPOLO();
                    this.maxDaytimePowerCount = getPOLO();
                    this.maxOutsidePowerCount = getPOLO();
                    this.spawnCurve = getPOLO();
                    this.daytimeSpawnCurve = getPOLO();
                    this.outsideSpawnCurve = getPOLO();
                    this.spawnProbabilityRange = getPOLO();
                    this.daytimeSpawnProbabilityRange = getPOLO();
                    this.enemies = getPOLO();
                    this.daytimeEnemies = getPOLO();
                    this.outsideEnemies = getPOLO();
                    this.price = getPOLO();
                    this.traps = getPOLO();
                    this.scrap = getPOLO();
                    this.dungeonFlows = getPOLO();
                    this.availableEnemies = {};
                    this.availableDaytimeEnemies = {};
                    this.availableOutsideEnemies = {};
                    this.availableItems = {};
                    this.availableFlows = {};
                    this.availableTraps = {};
                    this.availablePrices = {};
                    this.name = "<unnamed>";
                    this.id = "";
                }

                static bind(preset) {
                    const container = containerNode.cloneNode(true);

                    addEntry(container, "Preset", fromHtml(`<span style="width:150px;text-align: right;display:inline-block;"><b>${preset.id}</b></br></span>`));
                    // TODO Let the name be modifiable
                    // It will need to have additional handlers, like in the preset list, or for whatever else

                    // TODO Add inheritance!! Very important feature!!
                    // Use a select but default to none

                    container.appendChild(fromHtml(`<span><b>Scrap</b></br></span>`));
                    addEntry(container, "Scrap amount multiplier", new bindToggleableUnsignedFloat(preset.scrapAmountMultiplier));
                    addEntry(container, "Scrap value multiplier", new bindToggleableUnsignedFloat(preset.scrapValueMultiplier));
                    addEntry(container, "Min scrap", new bindToggleableUnsignedInt(preset.minScrap));
                    addEntry(container, "Max scrap", new bindToggleableUnsignedInt(preset.maxScrap));
                    addEntry(container, "Scrap", new UniqueRarityBoundList(preset.scrap, preset.availableItems, ItemType.bind).getElement());

                    container.appendChild(fromHtml(`<span><b>Interior Enemies</b></br></span>`));
                    addEntry(container, "Max power count", new bindToggleableUnsignedInt(preset.maxPowerCount));
                    addEntry(container, "Enemy spawn chance curve", new AnimationCurveBoundList(preset.spawnCurve).getElement());
                    addEntry(container, "Enemy spawn amount range", new bindToggleableUnsignedInt(preset.spawnProbabilityRange));
                    addEntry(container, "Enemies", new UniqueRarityBoundList(preset.enemies, preset.availableEnemies, EnemyType.bind).getElement());

                    container.appendChild(fromHtml(`<span><b>Daytime Enemies</b></br></span>`));
                    addEntry(container, "Max daytime power count", new bindToggleableUnsignedInt(preset.maxDaytimePowerCount));
                    addEntry(container, "Daytime enemy spawn chance curve", new AnimationCurveBoundList(preset.daytimeSpawnCurve).getElement());
                    addEntry(container, "Daytime enemy spawn amount range", new bindToggleableUnsignedInt(preset.daytimeSpawnProbabilityRange));
                    addEntry(container, "Daytime enemies", new UniqueRarityBoundList(preset.daytimeEnemies, preset.availableEnemies, EnemyType.bind).getElement());

                    container.appendChild(fromHtml(`<span><b>Outside Enemies</b></br></span>`));
                    addEntry(container, "Max outside power count", new bindToggleableUnsignedInt(preset.maxOutsidePowerCount));
                    addEntry(container, "Outside enemy spawn chance curve", new AnimationCurveBoundList(preset.outsideSpawnCurve).getElement());
                    addEntry(container, "Outside enemies", new UniqueRarityBoundList(preset.outsideEnemies, preset.availableEnemies, EnemyType.bind).getElement());

                    container.appendChild(fromHtml(`<span><b>Dungeon flows</b></br></span>`));
                    addEntry(container, "Map size multiplier", new bindToggleableUnsignedFloat(preset.mapSizeMultiplier));
                    addEntry(container, "Dungeon flows", new UniqueRarityBoundList(preset.dungeonFlows, preset.availableFlows, DungeonFlowType.bind).getElement());

                    container.appendChild(fromHtml(`<span><b>Traps</b></br></span>`));
                    addEntry(container, "Traps", new UniqueSelectBoundList(preset.traps, preset.availableTraps, TrapType.bind).getElement());

                    container.appendChild(fromHtml(`<span><b>Prices</b></br></span>`));
                    addEntry(container, "Prices", new UniqueSelectBoundList(preset.price, preset.availablePrices, PriceType.bind).getElement());

                    return container;
                }
            }

            
            class Configuration {
                constructor(data) {
                    this.defaults = data.defaults;
                    this.enemies = this.#generateEnemyTypes();
                    this.items = this.#generateItemTypes();
                    this.dungeonFlows = this.#generateDungeonFlows();
                    this.traps = this.#generateTrapTypes();
                    this.prices = this.#generatePrices();
                    this.levels = data.levels ? data.levels : {};
                    this.presets = data.presets ? data.presets : {};

                    this.generatePresets();
                    this.updatePresets();
                }

                getNewId() {
                    let id = null;
                    do {
                        id = "id" + Math.random().toString(16).slice(2)
                    } while (this.presets[id]);
                    return id;
                }

                generatePresets() {
                    for (const [levelId, levelInfo] of Object.entries(this.defaults.levels)) {
                        // Make sure every level has a valid preset linked to it
                        if (!this.levels[levelId]) {
                            console.log(`No preset detected for level ${levelId}, setting to preset ${levelId}`);
                            this.levels[levelId] = levelId;
                        } else if (!this.presets[this.levels[levelId]]) {
                            console.warn(`Preset ${this.levels[levelId]} for level ${levelId} does not exist, setting to preset ${levelId}`);
                        }

                        // Don't generate a default preset for this level if one already exists
                        if (this.presets[levelId]) {
                            console.log(`Found a default preset for ${levelId}`);
                            continue;
                        }

                        console.log(`No preset found with the id ${levelId}, creating`);

                        const preset = new Preset();
                        preset.id = levelId;
                        preset.name = (levelInfo.planet_name == null || levelInfo.planet_name === "") ? levelId : levelInfo.planet_name;
                        preset.mapSizeMultiplier.value = levelInfo.factory_size_multiplier
                        preset.scrapAmountMultiplier.value = this.defaults.scrap_amount_multiplier;
                        preset.scrapValueMultiplier.value = this.defaults.scrap_value_multiplier;
                        preset.minScrap.value = Math.min(levelInfo.min_scrap, levelInfo.max_scrap);
                        preset.maxScrap.value = Math.max(levelInfo.min_scrap, levelInfo.max_scrap);
                        preset.scrap.value = generateRaritiesFor(this.items, levelInfo.scrap);

                        preset.maxPowerCount.value = levelInfo.max_power_count;
                        preset.spawnCurve.value = structuredClone(levelInfo.enemy_spawn_curve);
                        preset.spawnProbabilityRange.value = levelInfo.enemy_spawn_probability_range;
                        preset.enemies.value = generateRaritiesFor(this.enemies, levelInfo.enemies);

                        preset.maxDaytimePowerCount.value = levelInfo.max_daytime_power_count;
                        preset.daytimeSpawnCurve.value = structuredClone(levelInfo.daytime_enemy_spawn_curve);
                        preset.daytimeSpawnProbabilityRange.value = levelInfo.daytime_enemy_spawn_probability_range;
                        preset.daytimeEnemies.value = generateRaritiesFor(this.enemies, levelInfo.daytime_enemies);

                        preset.maxOutsidePowerCount.value = levelInfo.max_outside_power_count;
                        preset.outsideSpawnCurve.value = structuredClone(levelInfo.outside_enemy_spawn_curve);
                        preset.outsideEnemies.value = generateRaritiesFor(this.enemies, levelInfo.outside_enemies);

                        preset.dungeonFlows.value = this.#generateDungeonFlowsFor(levelInfo.dungeon_flows);

                        preset.traps.value = this.#generateTrapsFor(levelInfo.spawnable_map_objects);

                        this.presets[preset.id] = preset;
                    }
                }

                updatePresets() {
                    for (const [id, preset] of Object.entries(this.presets)) {
                        preset.availableItems = structuredClone(this.items);
                        preset.availableEnemies = structuredClone(this.enemies);
                        preset.availableDaytimeEnemies = structuredClone(this.enemies);
                        preset.availableOutsideEnemies = structuredClone(this.enemies);
                        preset.availableFlows = structuredClone(this.dungeonFlows);
                        preset.availableTraps = structuredClone(this.traps);
                        preset.availablePrices = structuredClone(this.prices);

                        this.#removeUnknownId(preset.availableItems, preset.scrap.value);
                        this.#removeUnknownId(preset.availableEnemies, preset.enemies.value);
                        this.#removeUnknownId(preset.availableDaytimeEnemies, preset.daytimeEnemies.value);
                        this.#removeUnknownId(preset.availableOutsideEnemies, preset.outsideEnemies.value);
                        this.#removeUnknownId(preset.availableFlows, preset.dungeonFlows.value);
                        this.#removeUnknownId(preset.availableTraps, preset.traps.value);
                        this.#removeUnknownId(preset.availablePrices, preset.price.value);
                    }

                    for (const id of Object.keys(this.levels)) {
                        if (!this.defaults.levels[id]) {
                            console.log(`Found old level ${id}, removing`);
                            delete this.levels[id];
                        }
                    }
                }

                #removeUnknownId(options, list) {
                    let i = list?.length;
                    while (i--) {
                        if (!options[list[i].id]) {
                            list.splice(i, 1);
                        }
                    }
                }

                #generateTrapsFor(trapValues) {
                    const types = [];
                    for (const [id, type] of Object.entries(this.traps)) {
                        const copy = structuredClone(type);

                        copy.spawnCurve.value = trapValues[id];

                        types.push(copy);
                    }
                    return types;
                }

                #generateDungeonFlowsFor(flows) {
                    const types = generateRaritiesFor(this.dungeonFlows, flows);

                    for (const type of types) {
                        type.factorySizeMultiplier.value = this.defaults.map_size_multiplier;
                    }
                    return types;
                }

                #generateEnemyTypes() {
                    let types = {};
                    for (const [id, type] of Object.entries(this.defaults.enemies)) {
                        let jsType = new EnemyType();

                        jsType.maxEnemyCount.value = type.max_enemy_count;
                        jsType.powerLevel.value = type.power_level;
                        jsType.spawnChanceCurve.value = type.spawn_chance_curve;
                        jsType.stunTimeMultiplier.value = type.stun_time_multiplier;
                        jsType.doorSpeedMultiplier.value = type.door_speed_multiplier;
                        jsType.stunGameDifficultyMultiplier.value = type.stun_game_difficulty_multiplier;
                        jsType.stunnable.value = type.stunnable;
                        jsType.killable.value = type.killable;
                        jsType.enemyHp.value = type.enemy_hp;
                        jsType.spawnFalloffCurve.value = type.spawn_falloff_curve;
                        jsType.useSpawnFalloff.value = type.use_spawn_falloff;
                        jsType.name = type.name == null ? id : type.name;
                        jsType.id = id;

                        types[id] = jsType;
                    }
                    return types;
                }

                #generateItemTypes() {
                    let types = {};
                    for (const [id, type] of Object.entries(this.defaults.items)) {
                        let jsType = new ItemType();

                        jsType.weight.value = type.weight;
                        jsType.minValue.value = type.min_value;
                        jsType.maxValue.value = type.max_value;
                        jsType.conductive.value = type.conductive;
                        jsType.scrap = type.scrap;
                        jsType.name = type.name;
                        jsType.id = id;

                        types[id] = jsType;
                    }
                    return types;
                }

                #generateDungeonFlows() {
                    let types = {};
                    for (const flow of this.defaults.dungeon_flows) {
                        let jsType = new DungeonFlowType();

                        jsType.name = flow;
                        jsType.id = flow;

                        types[flow] = jsType;
                    }
                    return types;
                }

                #generateTrapTypes() {
                    let types = {};
                    for (const [id, type] of Object.entries(this.defaults.traps)) {
                        let jsType = new TrapType();

                        jsType.spawnFacingAwayFromWall = type.spawn_facing_away_from_wall;
                        jsType.name = id;
                        jsType.id = id;

                        types[id] = jsType;
                    }
                    return types;
                }

                #generatePrices() {
                    let prices = {};
                    for (const [id, level] of Object.entries(this.defaults.levels)) {
                        let jsType = new PriceType();

                        jsType.price.value = level.price;
                        jsType.name = (level.planet_name == null || level.planet_name === "") ? id : level.planet_name;
                        jsType.id = id;

                        prices[id] = jsType;
                    }
                    return prices;
                }
            }

            // Template for a container
            const containerNode = fromHtml('<div class="container"></div>');

            function fromHtml(html) {
                const template = document.createElement("template");
                template.innerHTML = html;
                const result = template.content.children;
                return result.length === 1 ? result[0] : result;
            }

            function addEntry(block, title, element) {
                const span = document.createElement("span");
                span.appendChild(fromHtml(`<span class="title">${title}</span>`));
                span.appendChild(element);
                span.appendChild(document.createElement("br"));
                block.appendChild(span);
            }


            // Current configuration that is being edited
            // TODO Ideally, move this into some anonymous double bound object somewhere
            var configuration = null;

            function selectFile(event) {
                let file = event.target.files[0];
                let reader = new FileReader();
                reader.onload = file => {
                    defaultData = JSON.parse(reader.result);
                    console.log("Parsed input data:");
                    console.log(defaultData);

                    // TODO Properly initialize the UI
                    configuration = new Configuration(defaultData);
                    for (const [id, preset] of Object.entries(configuration.presets)) {
                        addEntry(document.getElementById("subcontainer"), preset.name, new BindableSpoilerElement(preset, null, Preset.bind).getElement());
                    }
                };
                reader.readAsText(file);
            }

            // TODO Create the button and link the method dynamically
            function downloadConfiguration() {
                if (configuration) {
                    const copy = structuredClone(configuration.presets);
                    for (const val of Object.values(copy)) {
                        // Trim useless portions
                        delete val.availableItems;
                        delete val.availableEnemies;
                        delete val.availableDaytimeEnemies;
                        delete val.availableOutsideEnemies;
                        delete val.availableFlows;
                        delete val.availableTraps;
                        delete val.availablePrices;
                    }
                    // Follow the LQ json format
                    // defaults: <default data>
                    // presets: <presets>
                    // levels: <levels>

                    const exports = {
                        defaults: configuration.defaults,
                        presets: copy,
                        levels: configuration.levels
                    };

                    console.log("Exporting data:");
                    console.log(exports);

                    // TODO Decide on a standard file name
                    download("presets.json", JSON.stringify(exports));
                } else {
                    alert("Nothing to download!");
                }
            }

            function generateRaritiesFor(options, rarities) {
                const types = [];
                for (const [id, type] of Object.entries(options)) {
                    if (rarities[id]) {
                        const copy = structuredClone(type);
                        copy.rarity.value = rarities[id];
                        // Set it to true for now
                        copy.rarity.set = true;
                        types.push(copy);
                    }
                }
                return types;
            }

            function bindToggleableInt(obj, width = "") {
                const input = fromHtml(`<input type="number" step="1" style="width:${width};">`);
                obj.placeholder && (input.placeholder = obj.placeholder);
                return new ToggleableBoundElement(input, obj).getElement();
            }

            function bindToggleableUnsignedInt(obj, width = "") {
                const input = fromHtml(`<input type="number" min=0 step=1 style="width:${width};">`);
                obj.placeholder && (input.placeholder = obj.placeholder);
                return new ToggleableBoundElement(input, obj).getElement();
            }

            function bindInt(obj, width = "") {
                const input = fromHtml(`<input type="number" step="1" style="width:${width};">`);
                obj.placeholder && (input.placeholder = obj.placeholder);
                return new BoundElement(input, obj).getElement();
            }

            function bindToggleableFloat(obj, width = "") {
                const input = fromHtml(`<input type="number" style="width:${width};">`);
                obj.placeholder && (input.placeholder = obj.placeholder);
                return new ToggleableBoundElement(input, obj).getElement();
            }

            function bindToggleableUnsignedFloat(obj, width = "") {
                const input = fromHtml(`<input type="number" min=1 style="width:${width};">`);
                obj.placeholder && (input.placeholder = obj.placeholder);
                return new ToggleableBoundElement(input, obj).getElement();
            }

            function bindFloat(obj, width = "") {
                const input = fromHtml(`<input type="number" style="width:${width};">`);
                obj.placeholder && (input.placeholder = obj.placeholder);
                return new BoundElement(input, obj).getElement();
            }

            function bindToggleableBool(obj) {
                const select = fromHtml(`<select>
                <option value=true>True</option>
                <option value=false>False</option>
                </select>`);
                return new ToggleableBoundElement(select, obj).getElement();
            }

            function bindBool(obj) {
                const select = fromHtml(`<select>
                <option value=null></option>
                <option value=true>True</option>
                <option value=false>False</option>
                </select>`);
                return new BoundElement(select, obj).getElement();
            }

            // Insertion sort
            function addToSelect(sel, el) {
                let index = 0;
                for (; index < sel.options.length && el.text > sel.options[index].text; index++);
                if (index == sel.options.length) {
                    sel.options.add(el);
                } else {
                    sel.options.add(el, sel.options[index]);
                }
            }

            function download(filename, text) {
                const element = document.createElement('a');
                element.setAttribute('href', 'data:text/json;charset=utf-8,' + encodeURIComponent(text));
                element.setAttribute('download', filename);
                element.click();
            }
        </script>
        <style>
            div.editor {
                display: block;
            }
            div.container {
                vertical-align: text-top;
                outline-style: solid;
                border-radius: 2px;
                padding: 5px;
                margin: 5px;
                display: inline-block;
            }
            span.title {
                display: inline-block;
                margin-top: 5px;
                width: 200px;
                text-align: right;
            }
        </style>
    </head>
    <body>
        <input type="file" onchange="selectFile(event)">
        <button onclick="downloadConfiguration()">Download</button>
        <div class="editor" id="editor">
            <div class="container" id="presetlist">
                <span><b>Presets</b></span><br />
            </div>
            <div class="container" id="subcontainer">
            </div>
        </div>
    </body>
</html>