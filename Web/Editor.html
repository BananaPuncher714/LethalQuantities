<!DOCTYPE html>
<html>
    <head>
        <title>Lethal Quantities Web Editor</title>
        <script async>
            // Slow method, only for prototyping!!
            function fromHtml(html) {
                const template = document.createElement("template");
                template.innerHTML = html;
                const result = template.content.children;
                return result.length === 1 ? result[0] : result;
            }

            // Template for a container
            const prefabs = {
                container: fromHtml('<div class="container"></div>')
            };
            function createPrefabs() {
                prefabs.animationCurveKey = tooltip("Key", "The X-axis");

                {
                    const animationCurveValueBox = fromHtml("<span style=\"width:100px;display:inline-block;\"></span>");
                    animationCurveValueBox.appendChild(tooltip("Value", "The Y-axis"));
                    prefabs.animationCurveValue = animationCurveValueBox;
                }
                {
                    const link = document.createElement("a");
                    link.href = "https://lethal.miraheze.org/wiki/Mechanics";
                    link.target = "_blank";
                    link.textContent = "Animation Curves?";
                    prefabs.animationCurveLink = link;
                }
                {
                    prefabs.itemTypeMinValue = tooltip("Min value", "The minimum value of this item, inclusive. For example, a minimum value of 10 means the item can be sold for at least 10 credits.");
                    prefabs.itemTypeMaxValue = tooltip("Max value", "The maximum value of this item, exclusive. For example, a maximum value of 10 means this item can be sold for at most 9 credits.");
                    prefabs.itemTypeWeight = tooltip("Weight", "The weight in pounds of this item. You should make this consistent, otherwise certain values may not be properly calculate in-game(such as player weight). For example, create a global preset that all other presets inherit from, and set the weight there.");
                    prefabs.itemTypeConductive = tooltip("Conductive", "Whether or not this can be struck by lightning.");
                }
                {
                    prefabs.presetParent = tooltip("Parent", "Which preset to inherit from. Any disabled values in this preset will fallback to the parent preset, or the base game if none are set. By default none is selected. You can drag and drop a preset from the sidebar here to set the parent.");

                    prefabs.presetTitleScrap = tooltip(fromHtml(`<span><b>Scrap</b></span>`), "Settings for scrap items that spawn in the dungeon");
                    prefabs.presetScrapAmountMultiplier = tooltip("Scrap amount multiplier", "A multiplier that gets applied to the amount of scrap that will spawn. A multiplier of 1 means that the normal amount of scrap will spawn, while 0.5 means half, and 2 means twice as much, etc.");
                    prefabs.presetScrapValueMultiplier = tooltip("Scrap value multiplier", "A multiplier that gets applied to the value of each piece of scrap spawned. A multiplier of 1 means that the value will be unchanged, while 0.5 means the value will be halved, and 2 means the scrap will be worth twice as much.");
                    prefabs.presetScrapMin = tooltip("Min scrap", "The minimum amount of scrap that will be spawned(inclusive, so a value of 1 means that down to 1 piece of scrap can be spawned). The final amount is affected by the scrap amount multiplier. This includes ALL items in the scrap list(even store items). Less scrap may spawn if the dungeon does not provide enough scrap spawning locations.");
                    prefabs.presetScrapMax = tooltip("Max scrap", "The maximum amount of scrap that will be spawned(exclusive, so a value of 10 means that up to 9 pieces of scrap can be spawned). The final amount is affected by the scrap amount multiplier. This includes ALL items in the scrap list(even store items).");
                    prefabs.presetScrap = tooltip("Scrap", "The list of all spawnable items. This includes store items, which do not have a minimum or maximum value. Only items in this list will be allowed to spawn, regardless of the parent's scrap list. If you would like to include scrap from the parent's scrap list, you must add it to this list, but you do not have to set the rarity.");

                    prefabs.presetTitleEnemies = tooltip(fromHtml(`<span><b>Interior Enemies</b></span>`), "Settings for enemies that spawn inside");
                    prefabs.presetEnemiesMaxPower = tooltip("Max power count", "The maximum power count for enemies that spawn inside. Each enemy has a power level, which gets added to the level's power count when they are spawned. Once the level's power count is equal to this value, no more enemies are able to spawn. For example, a maximum power count of 10 means that 10 enemies with a power level of 1 can spawn. Enemies who would increase the power level above this value cannot be spawned. You should try to keep this value smaller than the total power count of all spawnable enemies(for example, 10 centipedes = 10 power).");
                    prefabs.presetEnemiesSpawnCurve = tooltip("Enemy spawn chance curve", "An animation curve describing the amount of enemies that can spawn at the given time. The key is represented by a value from 0 to 1, where 0 is when the day starts, and 1 is the latest time that the ship can leave. The value is the amount of enemies that will be spawned at the key.");
                    prefabs.presetEnemiesSpawnRange = tooltip("Enemy spawn amount range", "How much the value from the spawn chance curve can deviate. The total amount of enemies that will be spawned is randomly chosen from the spawn chance curve value minus the range, to the spawn chance curve value plus the range. For example, if the spawn chance curve value is 2, and the amount range is 3, then anywhere between 0 and 5 enemies can spawn.");
                    prefabs.presetEnemies = tooltip("Enemies", "The list of all spawnable interior enemies. Only enemies in this list will be allowed to spawn, regardless of the parent's enemies list. If you would like to include enemies from the parent's enemies list, you must add it to this list, but you do not have to set the rarity.");

                    prefabs.presetTitleOutside = tooltip(fromHtml(`<span><b>Outside Enemies</b></span>`), "Settings for enemies that spawn outside, normally at night. The spawn amount range is hardcoded to 3, and cannot be changed.");
                    prefabs.presetOutsideMaxPower = tooltip("Max outside power count", "The maximum power count for enemies that spawn outside(not including daytime enemies). Each enemy has a power level, which gets added to the level's power count when they are spawned. Once the level's power count is equal to this value, no more enemies are able to spawn. For example, a maximum power count of 10 means that 10 enemies with a power level of 1 can spawn. Enemies who would increase the power level above this value cannot be spawned. You should try to keep this value smaller than the total power count of all spawnable enemies(for example, 10 centipedes = 10 power).");
                    prefabs.presetOutsideSpawnCurve = tooltip("Outside enemy spawn chance curve", "An animation curve describing the amount of enemies that can spawn at the given time. The key is represented by a value from 0 to 1, where 0 is when the day starts, and 1 is the latest time that the ship can leave. The value is the amount of enemies that will be spawned at the key. You can set the curve so that enemies spawn outside early in the day.");
                    prefabs.presetOutside = tooltip("Outside enemies", "The list of all spawnable outside enemies. Only enemies in this list will be allowed to spawn, regardless of the parent's outside enemies list. If you would like to include enemies from the parent's enemies list, you must add it to this list, but you do not have to set the rarity.");

                    prefabs.presetTitleDaytime = tooltip(fromHtml(`<span><b>Daytime Enemies</b></span>`), "Settings for enemies that spawn outside, normally during the daytime");
                    prefabs.presetDaytimeMaxPower = tooltip("Max daytime power count", "The maximum power count for enemies that spawn outside(not including outside enemies). Each enemy has a power level, which gets added to the level's power count when they are spawned. Once the level's power count is equal to this value, no more enemies are able to spawn. For example, a maximum power count of 10 means that 10 enemies with a power level of 1 can spawn. Enemies who would increase the power level above this value cannot be spawned. You should try to keep this value smaller than the total power count of all spawnable enemies(for example, 10 centipedes = 10 power).");
                    prefabs.presetDaytimeSpawnCurve = tooltip("Daytime enemy spawn chance curve", "An animation curve describing the amount of enemies that can spawn at the given time. The key is represented by a value from 0 to 1, where 0 is when the day starts, and 1 is the latest time that the ship can leave. The value is the amount of enemies that will be spawned at the key. You can set the curve so that enemies spawn outside at night.");
                    prefabs.presetDaytimeSpawnRange = tooltip("Daytime enemy spawn amount range", "How much the value from the spawn chance curve can deviate. The total amount of enemies that will be spawned is randomly chosen from the spawn chance curve value minus the range, to the spawn chance curve value plus the range. For example, if the spawn chance curve value is 2, and the amount range is 3, then anywhere between 0 and 5 enemies can spawn.");
                    prefabs.presetDaytime = tooltip("Daytime enemies", "The list of all spawnable daytime enemies. Only enemies in this list will be allowed to spawn, regardless of the parent's daytime enemies list. If you would like to include enemies from the parent's enemies list, you must add it to this list, but you do not have to set the rarity.");

                    prefabs.presetTitleDungeons = tooltip(fromHtml(`<span><b>Dungeon flows</b></span>`), "Settings for dungeon flows. The overall map size is equal to the map size multiplier times the factory size multiplier");
                    prefabs.presetDungeonsMapSize = tooltip("Map size multiplier", "A multiplier that gets applied to the size of the dungeon flow. A value of 1 means that it generates at its regular size, while 0.5 means half, and 2 means twice as large. This value is multiplier by the factory size multiplier of the dungeon flow to find the final multiplier.");
                    prefabs.presetDungeons = tooltip("Dungeon flows", "The list of all available dungeon flows. Only dungeon flows in this list can be selected, regardless of the parent's dungeon flows list. If you would like to include flows from the parent's dungeon flows list, you must add it to this list, but you do not have to set the rarity.");

                    prefabs.presetTitleTraps = tooltip(fromHtml(`<span><b>Traps</b></span>`), "Settings for interior map objects, such as turrets, landmines, etc.");
                    prefabs.presetTraps = tooltip("Traps", "The list of all spawnable traps. Only objects in this list can be spawned, regardless of the parent's traps list. If you would like to include objects from the parent's traps list, you must add it to this list, but you do not have to set the spawn amount.");

                    prefabs.presetTitlePrices = tooltip(fromHtml(`<span><b>Prices</b></span>`), "Settings for prices of each moon. This is per-preset, so going to another moon with a different preset can result in different prices.");
                    prefabs.presetPrices = tooltip("Prices", "The list of prices for each moon. Moons not in this list will have their price set to the default. If you would like to use the parent's price for a particular moon, you must add it to this list but you do not have to set the price.");
                }
                {
                    prefabs.enemyTypeMaxCount = tooltip("Max enemy count", `The maximum amount of this enemy that can spawn`);
                    prefabs.enemyTypePowerLevel = tooltip("Power level", `How much one of this enemy contributes to the level's power count`);
                    prefabs.enemyTypeSpawnCurve = tooltip("Spawn chance curve", fromHtml(`<span>An animation curve controlling how likely this enemy to spawn throughout the day.<ul><li>The key ranges from 0 to 1, where 0 is the start of the day, and 1 is the latest time that the ship can leave.</li>
                            <li>The value is a multiplier that is multiplied by the rarity to find the final rarity to use when determining which enemy to spawn.</li></ul></span>`));
                    prefabs.enemyTypeStunMultiplier = tooltip("Stun time multiplier", "The multiplier on how long a stun grenade stuns this enemy. It is multiplied by the stun grenade effect duration(5 seconds) to find the total stun duration.");
                    prefabs.enemyTypeDoorMultiplier = tooltip("Door speed multiplier", "Probably how fast this enemy opens doors");
                    prefabs.enemyTypeStunDifficultyMultiplier = tooltip("Stun game difficulty multiplier", "I don't know what this setting is for");
                    prefabs.enemyTypeStunnable = tooltip("Stunnable", "Whether or not this enemy can be stunned. May not affect enemies that cannot be stunned by default.");
                    prefabs.enemyTypeKillable = tooltip("Killable", "Whether or not this enemy can be killed. Does not affect enemies that cannot be killed by default.");
                    prefabs.enemyTypeHp = tooltip("Enemy HP", "How many hitpoints this enemy has. By default, one shovel does one point of damage, while a shotgun does 5 damage.");
                    prefabs.enemyTypeSpawnFalloff = tooltip("Spawn falloff curve", fromHtml(`<span>An animation curve controlling how likely this enemy is to spawn based on how many of this enemy are already spawned.<ul><li>The key is how many have been spawned.</li><li>The value is a multiplier that is multiplied by the spawn chance multiplier to find the final multiplier.</li></ul>Only has an effect if <b>Use spawn falloff curve</b> is true.</span>`));
                    prefabs.enemyTypeUseFalloff = tooltip("Use spawn falloff curve", fromHtml(`<span>Whether or not to use the spawn falloff when calculating this enemy's rarity/weight.<ul><li>If enabled, the final rarity/weight of this enemy is the spawn falloff curve multiplier times the spawn chance multiplier times the rarity/weight.</li><li>If disabled, then the final rarity/weight of this enemy is the spawn chance multiplier times the rarity/weight</li></ul></span>`));
                }
                {
                    prefabs.trapTypeSpawnAmount = tooltip("Spawn amount", "How many of this trap will spawn. The key ranges from 0 to 1, and the value is the amount that will spawn. The key is randomly selected when generating the dungeon to find the final amount of this trap to spawn.");
                }
                {
                    prefabs.dungeonFlowSizeFactorySize = tooltip("Factory size multiplier", "The factory size multiplier of this particular dungeon flow. A value of 1 means that it generates at its regular size, while 0.5 means half, and 2 means twice as large. This value is multiplier by the map size multiplier to find the final multiplier.");
                }
                {
                    prefabs.priceTypePrice = tooltip("Price", "How many credits it costs to travel to this moon. If unset, it will use the parent's price value, or default value.");
                }

                {
                    prefabs.uniqueSelectBoundListEntryHeaderInner = fromHtml('<div style="text-overflow:ellipsis;white-space:nowrap;overflow:hidden;"></div>');
                    prefabs.uniqueSelectBoundListEntryHeaderOuter = fromHtml('<span style="max-width:200px;display:inline-block;vertical-align:bottom;"></span>');
                }
                {
                    prefabs.uniqueRarityBoundListRarity = tooltip("Rarity", "The rarity/weight of this entry. The probability of this entry being chosen is equal to this rarity/weight divided by the total sum of all the rarities/weights.");
                }
                {
                    prefabs.presetMenuBindEditorLevels = tooltip(fromHtml("<span><b>Levels</b></span>"), fromHtml("<span>Each level accepts a single preset, which is by default the autogenerated preset for that level. However, you can change it simply by dragging a preset from the sidebar on the left to the box on the right of a level.</span>"));
                    prefabs.presetMenuBindEditorPresets = tooltip(fromHtml(`<span><b>Presets</b></span>`), fromHtml(`<span>You can create more presets by clicking the <b>Add preset</b> button, or by clicking the <b>Copy</b> button next to an existing preset. You can change a preset's name by modifying
                            the text in the box, or delete a preset by clicking the <b>Delete</b> button twice.<br><br>There is one preset per level, which is autogenerated if it does not exist. If you mess up on a default preset, and would like to regenerate it, you can delete it then reload the page. However,
                            it is advised that you create a copy of the default preset that you want to modify, then modify your copy.</span>`));
                }
            }
            createPrefabs();

            class BoundElement {
                constructor( element, obj ) {
                    this.data = obj;
                    this.element = element;
                    element.value = obj.value;
                    element.addEventListener("change", event => this.change(this.element.value));
                }

                change( value ) {
                    this.data.value = value;
                    this.element.value = value;
                    this.data.set = !( this.element.value == null || this.element.value == "" );
                }

                getElement() {
                    return this.element;
                }
            }

            class ToggleableBoundElement extends BoundElement {
                constructor(input, obj) {
                    super(input, obj);

                    this.box = document.createElement("input");
                    this.box.type = "checkbox";
                    this.box.checked = obj.set;
                    this.box.addEventListener("change", event => this.set());

                    this.bar = document.createElement("span");
                    this.bar.append(this.box, this.element);

                    this.set();
                }

                change(value) {
                    super.change(value);
                    this.set();
                }

                set() {
                    this.data.set = !(this.element.value == null || this.element.value == "") && this.box.checked;
                    this.element.disabled = !this.box.checked;
                }

                getElement() {
                    return this.bar;
                }
            }

            class BoundList {
                constructor( obj ) {
                    this.data = obj;

                    // Map object to html node
                    this.objectRows = new Map();

                    this.addButton = document.createElement("button");
                    this.addButton.textContent = "+";
                    this.addButton.onclick = () => this.addElement();

                    this.bar = document.createElement("span");
                    this.bar.appendChild( this.addButton );

                    // Container for holding entries
                    this.selectables = document.createElement( "div" );

                    this.container = document.createElement("div");
                    this.container.classList.add("container");
                    this.container.appendChild(this.bar, document.createElement("br") );
                    this.container.appendChild( this.selectables );

                    this.spoiler = new SpoilerElement(obj, this.container);
                    this.spoilered = this.spoiler.getElement();

                    this.box = document.createElement("input");
                    this.box.type = "checkbox";
                    this.box.addEventListener("change", event => this.set(this.box.checked));

                    const element = document.createElement( "span" );
                    element.append( this.box, this.spoilered );

                    this.element = element;

                    this.set( obj.set );
                }

                set( value ) {
                    this.box.checked = value;
                    this.data.set = value;
                    this.spoilered.style.display = value ? "" : "none";
                }

                getElement() {
                    return this.element;
                }

                removeElement(object) {
                    this.data.value.splice(this.data.value.findIndex(o => o === object), 1);
                    this.data.onremove?.(object);
                    this.selectables.removeChild(this.objectRows.get(object));
                    this.objectRows.delete(object);
                }

                addElement(element, object) {
                    const deleteButton = document.createElement("button");
                    deleteButton.textContent = "X";
                    deleteButton.onclick = () => {
                        this.removeElement(object);
                    };

                    const row = document.createElement( "span" );
                    row.appendChild(deleteButton);
                    if (element) {
                        row.appendChild(element);
                    }
                    row.appendChild( document.createElement( "br" ) );

                    this.selectables.appendChild( row );
                    this.data.value.push(object);
                    this.objectRows.set(object, row);
                    
                    return row;
                }
            }

            class AnimationCurveBoundList extends BoundList {
                constructor( obj ) {
                    super( obj );

                    if (!obj.value) {
                        obj.value = [];
                    }
                    
                    let original = [...obj.value];
                    obj.value.length = 0;
                    for ( let i = 0; i < original.length; i++ ) {
                        this.addElement(null, original[i]);
                    }

                    this.bar.append(prefabs.animationCurveKey.cloneNode(true), prefabs.animationCurveValue.cloneNode(true));
                    this.spoiler.header.appendChild(prefabs.animationCurveLink.cloneNode(true));
                }

                addElement(element, frame = {value: null, time: null}) {
                    const time = document.createElement("input");
                    time.type = "number";
                    time.min = 0;
                    time.style.width = "100px";
                    time.value = frame.time;
                    time.addEventListener("change", event => {
                        switch (event.type) {
                            case "change": frame.time = time.value;
                        }
                    }, false);

                    const value = document.createElement("input");
                    value.type = "number";
                    value.style.width = "100px";
                    value.value = frame.value;
                    value.addEventListener("change", event => {
                        switch (event.type) {
                            case "change": frame.value = value.value;
                        }
                    }, false);

                    const span = document.createElement("span");
                    span.append(time, value);
                    if (element) {
                        span.appendChild(element);
                    }

                    return super.addElement(span, frame);
                }
            }

            class UniqueSelectBoundList extends BoundList {
                constructor( obj, options, binder ) {
                    super( obj );

                    this.options = options;
                    // Map of all available options
                    this.selectOptions = {};
                    // Array of removed options
                    this.filtered = [];

                    // Contains one object per entry
                    // container: The html node
                    // spoiler: The spoiler element
                    // header: The header
                    this.entries = {};

                    // Binds the given object and returns a DOM element
                    this.binder = binder;

                    if (!obj.value) {
                        obj.value = [];
                    }

                    // Keep track of which objects have a duplicate name, for whatever reason
                    // Happens in the case where the enemy does not have a fully create scan node
                    this.duplicates = {};
                    for (const [id, val] of Object.entries(options)) {
                        if (!this.duplicates[id]) {
                            for (const option of Object.values(options)) {
                                if (option !== val && option.name == val.name) {
                                    this.duplicates[id] = true;
                                    this.duplicates[option.id] = true;
                                }
                            }
                        }
                    }

                    const addSelect = document.createElement("select");
                    addSelect.style.minWidth = "200px";
                    addSelect.style.maxWidth = "200px";
                    for (const [key, value] of Object.entries(options)) {
                        const optionEl = new Option(this.duplicates[key] ? (value.name + "(" + value.id + ")") : value.name, key);
                        addToSelect(addSelect, optionEl);
                        this.selectOptions[key] = optionEl;
                    }
                    this.selected = addSelect;

                    this.searchBar = document.createElement("input");
                    this.searchBar.type = "search";
                    this.searchBar.addEventListener("input", e => {
                        this.updateSearch();
                        this.onBigUpdate();
                    });

                    const showAll = document.createElement("button");
                    showAll.textContent = "Show All"
                    showAll.onclick = () => {
                        for (const [key, entry] of Object.entries(this.entries)) {
                            if (entry.container.style.display !== "none") {
                                entry.spoiler.setOpen(true);
                            }
                        }
                    };

                    const hideAll = document.createElement("button");
                    hideAll.textContent = "Hide all";
                    hideAll.onclick = () => {
                        for (const [key, entry] of Object.entries(this.entries)) {
                            if (entry.container.style.display !== "none") {
                                entry.spoiler.setOpen(false);
                            }
                        }
                    };

                    let addClicked = false;
                    const addAll = document.createElement("button");
                    addAll.textContent = "Add all";
                    addAll.addEventListener("focusout", () => {
                        addClicked = false;
                        addAll.style.color = "";
                    });
                    addAll.addEventListener("click", () => {
                        if (addClicked) {
                            addClicked = false;
                            addAll.style.color = "";

                            while (this.selected.children.length > 0) {
                                this.addElement();
                            }
                            this.onBigUpdate();
                        } else {
                            addClicked = true;
                            addAll.style.color = "blue";
                        }
                    });

                    let removeClicked = false;
                    const removeAll = document.createElement("button");
                    removeAll.textContent = "Remove all";
                    removeAll.addEventListener("focusout", () => {
                        removeClicked = false;
                        removeAll.style.color = "";
                    });
                    removeAll.addEventListener("click", () => {
                        if (removeClicked) {
                            removeClicked = false;
                            removeAll.style.color = "";

                            for (const [key, value] of Object.entries(this.entries)) {
                                if (value.container.style.display !== "none") {
                                    this.removeElement(this.options[key], false);
                                }
                            }
                            this.updateSearch();
                            this.onBigUpdate();
                        } else {
                            removeClicked = true;
                            removeAll.style.color = "orange";
                        }
                    });
                    this.bar.append(addSelect, this.searchBar, document.createElement("br"), showAll, hideAll, addAll, removeAll);

                    let original = [...obj.value];
                    obj.value.length = 0;
                    for (let i = 0; i < original.length; i++) {
                        this.addElement(null, original[i]);
                    }

                    const containsAny = this.selected.children.length > 0;
                    this.selected.disabled = !containsAny;
                    this.addButton.disabled = !containsAny;
                }

                updateSearch() {
                    const search = this.searchBar.value.toLowerCase().replace(/\s/g, '');
                    if (search == null || search == "") {
                        // Reset all filtered options
                        for (const [id, val] of Object.entries(this.entries)) {
                            if (!this.isFiltered(id)) {
                                val.container.style.display = "";
                            } else {
                                val.container.style.display = "none";
                            }
                        }
                        for (let i = 0; i < this.filtered.length; i++) {
                            addToSelect(this.selected, this.filtered[i]);
                        }
                        this.filtered.length = 0;
                    } else {
                        // Get ones that need to be added
                        const add = []
                        for (let i = this.filtered.length - 1; i >= 0; i--) {
                            const option = this.filtered[i];
                            const label = option.label.toLowerCase().replace(/\s/g, '');
                            const value = option.value.toLowerCase().replace(/\s/g, '');
                            if (label.includes(search) || value.includes(search)) {
                                add.push(option);
                                this.filtered.splice(i, 1);
                            }
                        }
                        
                        // Get ones that need to be removed
                        const remove = [];
                        for (let i = 0; i < this.selected.children.length; i++) {
                            const option = this.selected.children[i];
                            const label = option.label.toLowerCase().replace(/\s/g, '');
                            const value = option.value.toLowerCase().replace(/\s/g, '');
                            if (!(label.includes(search) || value.includes(search))) {
                                remove.push(option);
                                this.filtered.push(option);
                            }
                        }

                        // Make changes here, to prevent iterating over some options multiple times
                        for (let i = 0; i < remove.length; i++) {
                            this.selected.removeChild(remove[i]);
                        }
                        for (let i = 0; i < add.length; i++) {
                            addToSelect(this.selected, add[i]);
                        }

                        // Filter all added objects
                        for (const [key, val] of Object.entries(this.entries)) {
                            const option = this.options[key];
                            const id = option.id?.toLowerCase().replace(/\s/g, '');
                            const name = option.name?.toLowerCase().replace(/\s/g, '');
                            if ((id?.includes(search) || name?.includes(search)) && !this.isFiltered(key)) {
                                val.container.style.display = "";
                            } else {
                                val.container.style.display = "none";
                            }
                        }
                    }

                    const containsAny = this.selected.children.length > 0;
                    this.selected.disabled = !containsAny;
                    this.addButton.disabled = !containsAny;
                }

                isFiltered(key) {
                    return false;
                }

                onBigUpdate() {
                }

                removeElement(object, updateAll = true) {
                    addToSelect(this.selected, this.selectOptions[object.id]);
                    if (updateAll) {
                        this.updateSearch();
                    }

                    delete this.entries[object.id];

                    super.removeElement(object);
                }

                addElement(element, object) {
                    // Should element be used?
                    // Could clone if the data should be reset when re-added
                    if (object) {
                        // Set the current option to the provided object, if not null
                        this.options[object.id] = object;
                    } else {
                        // Get the object if null
                        object = this.options[this.selected.value];
                    }
                    const id = object.id;
                    this.selected.removeChild(this.selectOptions[id]);
                    if (this.selected.children.length == 0) {
                        this.selected.disabled = true;
                        this.addButton.disabled = true;
                    }

                    const innerEl = prefabs.uniqueSelectBoundListEntryHeaderInner.cloneNode(true);
                    innerEl.textContent = this.duplicates[id] ? `${object.name}(${id})` : object.name;

                    const outerEl = prefabs.uniqueSelectBoundListEntryHeaderOuter.cloneNode(true);
                    outerEl.appendChild(innerEl);

                    const descriptionBox = document.createElement("span");
                    descriptionBox.append(`Name: ${object.name}`, document.createElement("br"), `ID: ${id}`);
                    if (object.description) {
                        descriptionBox.append(document.createElement("br"), `Description: ${object.description}`);
                    }

                    const tooltipBox = document.createElement("span");
                    tooltipBox.style.width = "200px";
                    tooltipBox.style.display = "inline-block";
                    tooltipBox.appendChild(tooltip(outerEl, descriptionBox));

                    const header = document.createElement("span");
                    header.appendChild(tooltipBox);

                    const spoiler = new BindableSpoilerElement(object, header, this.binder);

                    const superEl = super.addElement(spoiler.getElement(), object);

                    // Add to added options
                    this.entries[id] = {
                        container: superEl,
                        spoiler: spoiler,
                        header: header,
                    };

                    if (!this.isFiltered(id)) {
                        superEl.style.display = "";
                    } else {
                        superEl.style.display = "none";
                    }

                    return superEl;
                }
            }

            class UniqueRarityBoundList extends UniqueSelectBoundList {
                constructor( obj, options, binder ) {
                    super( obj, options, binder );

                    this.raritySelect = document.createElement("select");
                    this.raritySelect.options.add(new Option("All", "none", true));
                    this.raritySelect.options.add(new Option("Enabled", "selected", true));
                    this.raritySelect.options.add(new Option("Disabled", "deselected", true));
                    this.raritySelect.addEventListener("change", event => {
                        this.updateSearch();

                        this.onBigUpdate();
                    });

                    this.visibleCounter = document.createElement("span");
                    this.visibleCounter.style.width = "40px";
                    this.visibleCounter.style.display = "inline-block";

                    const weightTitle = document.createElement("span");
                    weightTitle.classList.add("title");
                    weightTitle.textContent = "Total rarity/weight:";

                    this.weightCounter = document.createElement("span");
                    this.updateRarities();

                    const span = document.createElement("span");
                    span.append(document.createElement("br"), "Display", this.raritySelect, this.visibleCounter, weightTitle, this.weightCounter);

                    const selectAll = document.createElement("button");
                    selectAll.textContent = "Enable all";
                    selectAll.addEventListener("click", () => {
                        for (const [key, entry] of Object.entries(this.entries)) {
                            if (entry.container.style.display !== "none") {
                                entry.rarityUpdate(true);
                            }
                        }
                        this.updateRarities();
                    });
                    const deselectAll = document.createElement("button");
                    deselectAll.textContent = "Disable all";
                    deselectAll.addEventListener("click", () => {
                        for (const [key, entry] of Object.entries(this.entries)) {
                            if (entry.container.style.display !== "none") {
                                entry.rarityUpdate(false);
                            }
                        }
                        this.updateRarities();
                    });

                    this.bar.append(selectAll, deselectAll, span);
                    this.onBigUpdate();
                }

                removeElement(object) {
                    super.removeElement(object);

                    this.updateRarities();
                }

                isFiltered(key) {
                    if (!this.raritySelect) {
                        return super.isFiltered(key);
                    }

                    const rarity = this.options[key].rarity;
                    switch (this.raritySelect.value) {
                        case "deselected":
                            return rarity.set || rarity.value === 0;
                        case "selected":
                            return (!rarity.set || rarity.value === 0)
                        default:
                            return super.isFiltered(key);
                    }
                }

                onBigUpdate() {
                    this.visibleCounter.textContent = `(${Object.values(this.entries).filter(e => e.container.style.display !== "none").length}/${Object.keys(this.entries).length})`;
                }

                addElement(element, object) {
                    const id = object ? object.id : this.selected.value;
                    const el = super.addElement(element, object);
                    const obj = this.options[id];

                    // We want to handle the rarity with more control, so implement the binding ourselves
                    const box = document.createElement("input");
                    box.type = "checkbox";

                    const input = document.createElement("input");
                    input.type = "number";
                    input.step = 1;
                    input.style.width = "50px";

                    const probability = document.createElement("input");
                    probability.disabled = true;
                    probability.style.width = "50px";

                    const rarity = obj.rarity;
                    this.entries[id].rarity = rarity;
                    this.entries[id].rarityBox = probability;

                    input.value = rarity.value;
                    const set = (updateBox = false) => {
                        rarity.set = !(input.value == null || input.value == "") && box.checked;
                        if (updateBox) {
                            input.disabled = !box.checked;
                        }
                    };

                    const setAndUpdate = (updateBox = false) => {
                        set(updateBox);

                        this.updateRarities();
                    };

                    box.checked = rarity.set;
                    box.addEventListener("change", event => {
                        setAndUpdate(true);
                    });
                    setAndUpdate();

                    input.addEventListener("change", event => {
                        rarity.value = input.value;
                       
                        setAndUpdate();
                    });

                    this.entries[id].rarityUpdate = (enabled) => {
                        box.checked = enabled;
                        set(true);
                    };

                    // Optional, just for organization
                    const bar = document.createElement("span");
                    bar.append(box, input, probability);

                    this.entries[id].header.append(prefabs.uniqueRarityBoundListRarity.cloneNode(true), bar);
                    // TODO Fine tune this, with like a slider, locking the weight, etc

                    return el;
                }

                updateRarities() {
                    let total = 0;
                    for (const entry of Object.values(this.entries)) {
                        if (entry.rarity.set) {
                            total += parseInt(entry.rarity.value);
                        }
                    }
                    for (const entry of Object.values(this.entries)) {
                        if (entry.rarity.set && total > 0) {
                            entry.rarityBox.value = `${Math.round(10000 * parseInt(entry.rarity.value) / total) / 100}%`;
                        } else {
                            entry.rarityBox.value = "0%";
                        }
                    }

                    if (this.weightCounter) {
                        this.weightCounter.textContent = total;
                    }
                }
            }

            // Kind of a redundant class, can be replaced with summary
            class SpoilerElement {
                constructor(obj, element, after = null) {

                    const hidden = obj.hidden;
                    const setting = { display: "", open: hidden };
                    const box = document.createElement("button");
                    box.textContent = "H";
                    box.onclick = () => {
                        this.setOpen(!this.setting.open);
                    };

                    const span = document.createElement("span");
                    span.appendChild(box);
                    if (after) {
                        span.appendChild(after);
                    }

                    const spacer = document.createElement("span");
                    spacer.classList.add("title");
                    const extra = document.createElement("span");
                    extra.append(document.createElement("br"), spacer, element);

                    this.header = document.createElement("span");
                    span.appendChild(this.header, extra);
                    span.appendChild(extra);

                    this.object = obj;
                    this.inner = extra;
                    this.setting = setting;
                    this.box = box;
                    this.el = span;

                    this.setOpen(!hidden);
                }

                getElement() {
                    return this.el;
                }

                setOpen(option) {
                    if (option) {
                        this.inner.style.display = this.setting.display;
                        this.box.textContent = "H";
                    } else {
                        if (this.setting.open) {
                            this.setting.display = this.inner.style.display;
                        }
                        this.inner.style.display = "none";
                        this.box.textContent = "S";
                    }
                    this.object.hidden = !option;
                    this.setting.open = option;
                }
            }

            class BindableSpoilerElement {
                constructor(bindableElement, after = null, binder) {

                    const hidden = bindableElement.hidden;
                    const setting = { display: "", open: hidden };
                    const box = document.createElement("button");
                    box.textContent = "H";
                    box.onclick = () => {
                        this.setOpen(!this.setting.open);
                    };

                    const span = document.createElement("span");
                    span.appendChild(box);
                    if (after) {
                        span.appendChild(after);
                    }
                    this.header = document.createElement("span");
                    span.appendChild(this.header);

                    this.binder = binder;
                    this.inner = bindableElement;
                    this.setting = setting;
                    this.box = box;
                    this.el = span;

                    this.setOpen(!hidden);
                }

                getElement() {
                    return this.el;
                }

                setOpen(option) {
                    if (option) {
                        if (!this.setting.open) {
                            this.boundNode = document.createElement("span");
                            // As long as certain things aren't spoilered with this, not adding in a spacer is fine
                            //const spacer = document.createElement("span");
                            //spacer.classList.add("title");
                            //this.boundNode.append(document.createElement("br"), spacer, this.binder(this.inner));
                            this.boundNode.append(document.createElement("br"), this.binder(this.inner));

                            this.el.appendChild(this.boundNode);
                            this.box.textContent = "H";
                        }
                    } else {
                        if (this.boundNode) {
                            this.el.removeChild(this.boundNode);
                        }
                        this.boundNode = null;
                        this.box.textContent = "S";
                    }
                    this.inner.hidden = !option;
                    this.setting.open = option;
                }
            }

            // Plain old lethal object
            // Better than plain old optional object
            function getPOLO() {
                return {
                    value: null,
                    set: false
                };
            }

            class EnemyType {
                constructor() {
                    this.maxEnemyCount = getPOLO();
                    this.powerLevel = getPOLO();
                    this.spawnChanceCurve = getPOLO();
                    this.stunTimeMultiplier = getPOLO();
                    this.doorSpeedMultiplier = getPOLO();
                    this.stunGameDifficultyMultiplier = getPOLO();
                    this.stunnable = getPOLO();
                    this.killable = getPOLO();
                    this.enemyHp = getPOLO();
                    this.spawnFalloffCurve = getPOLO();
                    this.useSpawnFalloff = getPOLO();
                    this.rarity = getPOLO();
                    this.hasSpawnFalloff = true;
                    this.name = "";
                    this.id = "";
                }

                static bind(enemy) {
                    const container = prefabs.container.cloneNode(true);
                    addEntry(container, prefabs.enemyTypeMaxCount.cloneNode(true), bindToggleableUnsignedInt(enemy.maxEnemyCount));
                    addEntry(container, prefabs.enemyTypePowerLevel.cloneNode(true), bindToggleableUnsignedInt(enemy.powerLevel));
                    addEntry(container, prefabs.enemyTypeSpawnCurve.cloneNode(true), new AnimationCurveBoundList(enemy.spawnChanceCurve).getElement());
                    addEntry(container, prefabs.enemyTypeStunMultiplier.cloneNode(true), bindToggleableUnsignedFloat(enemy.stunTimeMultiplier));
                    addEntry(container, prefabs.enemyTypeDoorMultiplier.cloneNode(true), bindToggleableUnsignedFloat(enemy.doorSpeedMultiplier));
                    addEntry(container, prefabs.enemyTypeStunDifficultyMultiplier.cloneNode(true), bindToggleableUnsignedFloat(enemy.stunGameDifficultyMultiplier));
                    addEntry(container, prefabs.enemyTypeStunnable.cloneNode(true), bindToggleableBool(enemy.stunnable));
                    addEntry(container, prefabs.enemyTypeKillable.cloneNode(true), bindToggleableBool(enemy.killable));
                    addEntry(container, prefabs.enemyTypeHp.cloneNode(true), bindToggleableUnsignedInt(enemy.enemyHp));
                    if (enemy.hasSpawnFalloff) {
                        addEntry(container, prefabs.enemyTypeSpawnFalloff.cloneNode(true), new AnimationCurveBoundList(enemy.spawnFalloffCurve).getElement());
                        addEntry(container, prefabs.enemyTypeUseFalloff.cloneNode(true), bindToggleableBool(enemy.useSpawnFalloff));
                    }
                    return container;
                }
            }

            class ItemType {
                constructor() {
                    this.weight = getPOLO();
                    this.minValue = getPOLO();
                    this.maxValue = getPOLO();
                    this.conductive = getPOLO();
                    this.rarity = getPOLO();
                    this.scrap = true;
                    this.name = "";
                    this.id = "";
                }

                static bind(item, includeWeight = true) {
                    const container = prefabs.container.cloneNode(true);
                    if (item.scrap) {
                        addEntry(container, prefabs.itemTypeMinValue.cloneNode(true), bindToggleableUnsignedInt(item.minValue));
                        addEntry(container, prefabs.itemTypeMaxValue.cloneNode(true), bindToggleableUnsignedInt(item.maxValue));
                    }
                    if (includeWeight) {
                        addEntry(container, prefabs.itemTypeWeight.cloneNode(true), bindToggleableUnsignedFloat(item.weight));
                    }
                    addEntry(container, prefabs.itemTypeConductive.cloneNode(true), bindToggleableBool(item.conductive));
                    return container;
                }
            }

            class TrapType {
                constructor() {
                    this.spawnCurve = getPOLO();
                    this.spawnFacingAwayFromWall = false;
                    this.description = "";
                    this.name = "";
                    this.id = "";
                }

                static bind(trap) {
                    const container = prefabs.container.cloneNode(true);
                    addEntry(container, prefabs.trapTypeSpawnAmount.cloneNode(true), new AnimationCurveBoundList(trap.spawnCurve).getElement());
                    return container;
                }
            }

            class DungeonFlowType {
                constructor() {
                    this.factorySizeMultiplier = getPOLO();
                    this.rarity = getPOLO();
                    this.name = "";
                    this.id = "";
                }

                static bind(flow) {
                    const container = prefabs.container.cloneNode(true);
                    addEntry(container, prefabs.dungeonFlowSizeFactorySize.cloneNode(true), new bindToggleableUnsignedFloat(flow.factorySizeMultiplier));
                    return container;
                }
            }

            class PriceType {
                constructor() {
                    this.price = getPOLO();
                    this.name = "";
                    this.id = "";
                }

                static bind(price) {
                    const container = prefabs.container.cloneNode(true);
                    addEntry(container, prefabs.priceTypePrice.cloneNode(true), new bindToggleableUnsignedInt(price.price));
                    return container;
                }
            }

            class Preset {
                constructor() {
                    this.mapSizeMultiplier = getPOLO();
                    this.scrapAmountMultiplier = getPOLO();
                    this.scrapValueMultiplier = getPOLO();
                    this.minScrap = getPOLO();
                    this.maxScrap = getPOLO();
                    this.maxPowerCount = getPOLO();
                    this.maxDaytimePowerCount = getPOLO();
                    this.maxOutsidePowerCount = getPOLO();
                    this.spawnCurve = getPOLO();
                    this.daytimeSpawnCurve = getPOLO();
                    this.outsideSpawnCurve = getPOLO();
                    this.spawnProbabilityRange = getPOLO();
                    this.daytimeSpawnProbabilityRange = getPOLO();
                    this.enemies = getPOLO();
                    this.daytimeEnemies = getPOLO();
                    this.outsideEnemies = getPOLO();
                    this.price = getPOLO();
                    this.traps = getPOLO();
                    this.scrap = getPOLO();
                    this.dungeonFlows = getPOLO();
                    this.availableEnemies = {};
                    this.availableDaytimeEnemies = {};
                    this.availableOutsideEnemies = {};
                    this.availableItems = {};
                    this.availableFlows = {};
                    this.availableTraps = {};
                    this.availablePrices = {};
                    this.parent = undefined;
                    this.name = "<unnamed>";
                    this.id = "";
                }

                static bind(preset, parents = {}) {
                    const boldIdentifier = document.createElement("b");
                    boldIdentifier.textContent = preset.name || preset.id;
                    const identifierTooltip = document.createElement("span");
                    identifierTooltip.appendChild(boldIdentifier);
                    const identifierText = document.createElement("span");
                    identifierText.append(`Name: ${preset.name}`, document.createElement("br"), `ID: ${preset.id}`);
                    const identifier = tooltip(identifierTooltip, identifierText);

                    const spacer = document.createElement("span");
                    spacer.style.minWidth = "100px";
                    spacer.style.display = "inline-block";
                    const identifierSpan = document.createElement("span");
                    identifierSpan.style.display = "inline-block";
                    identifierSpan.append(spacer, identifier, document.createElement("br"));

                    const presetTitle = document.createElement("b");
                    presetTitle.textContent = "Preset";

                    const container = prefabs.container.cloneNode(true);
                    addEntry(container, presetTitle, identifierSpan);

                    // Set the parent here
                    const select = document.createElement("select");
                    select.style.maxWidth = "200px";
                    select.options.add(new Option("", undefined, true, preset.parent));
                    for (const [id, potential] of Object.entries(parents)) {
                        if (id !== preset.id) {
                            select.options.add(new Option(potential.name || potential.id, potential.id, false, id === preset.parent));
                        }
                    }

                    select.addEventListener("change", () => {
                        preset.parent = select.value;
                    });

                    select.addEventListener("dragover", ev => {
                        ev.preventDefault();
                        ev.dataTransfer.dropEffect = "link";
                    });
                    select.addEventListener("drop", ev => {
                        const presetId = ev.dataTransfer.getData("text/plain");
                        if (parents[presetId]) {
                            ev.preventDefault();
                            ev.dataTransfer.dropEffect = "link";
                            select.value = presetId;
                            preset.parent = presetId;
                        }
                    });

                    addEntry(container, prefabs.presetParent.cloneNode(true), select);

                    const col1 = document.createElement("span");
                    col1.style.gridColumn = "1/2";
                    col1.style.padding = "4px";
                    const col2 = document.createElement("span");
                    col2.style.gridColumn = "2/3";
                    col2.style.padding = "4px";

                    // Don't really have to clone these spoilers, since they're used only once
                    col2.append(prefabs.presetTitleScrap.cloneNode(true), document.createElement("br"));
                    addEntry(col2, prefabs.presetScrapAmountMultiplier.cloneNode(true), new bindToggleableUnsignedFloat(preset.scrapAmountMultiplier));
                    addEntry(col2, prefabs.presetScrapAmountMultiplier.cloneNode(true), new bindToggleableUnsignedFloat(preset.scrapValueMultiplier));
                    addEntry(col2, prefabs.presetScrapMin.cloneNode(true), new bindToggleableUnsignedInt(preset.minScrap));
                    addEntry(col2, prefabs.presetScrapMax.cloneNode(true), new bindToggleableUnsignedInt(preset.maxScrap));
                    addEntry(col2, prefabs.presetScrap.cloneNode(true), new UniqueRarityBoundList(preset.scrap, preset.availableItems, ItemType.bind).getElement());

                    col1.append(prefabs.presetTitleEnemies.cloneNode(true), document.createElement("br"));
                    addEntry(col1, prefabs.presetEnemiesMaxPower.cloneNode(true), new bindToggleableUnsignedInt(preset.maxPowerCount));
                    addEntry(col1, prefabs.presetEnemiesSpawnCurve.cloneNode(true), new AnimationCurveBoundList(preset.spawnCurve).getElement());
                    addEntry(col1, prefabs.presetEnemiesSpawnRange.cloneNode(true), new bindToggleableUnsignedFloat(preset.spawnProbabilityRange));
                    addEntry(col1, prefabs.presetEnemies.cloneNode(true), new UniqueRarityBoundList(preset.enemies, preset.availableEnemies, EnemyType.bind).getElement());

                    col1.append(prefabs.presetTitleOutside.cloneNode(true), document.createElement("br"));
                    addEntry(col1, prefabs.presetOutsideMaxPower.cloneNode(true), new bindToggleableUnsignedInt(preset.maxOutsidePowerCount));
                    addEntry(col1, prefabs.presetOutsideSpawnCurve.cloneNode(true), new AnimationCurveBoundList(preset.outsideSpawnCurve).getElement());
                    addEntry(col1, prefabs.presetOutside.cloneNode(true), new UniqueRarityBoundList(preset.outsideEnemies, preset.availableOutsideEnemies, EnemyType.bind).getElement());

                    col1.append(prefabs.presetTitleDaytime.cloneNode(true), document.createElement("br"));
                    addEntry(col1, prefabs.presetDaytimeMaxPower.cloneNode(true), new bindToggleableUnsignedInt(preset.maxDaytimePowerCount));
                    addEntry(col1, prefabs.presetDaytimeSpawnCurve.cloneNode(true), new AnimationCurveBoundList(preset.daytimeSpawnCurve).getElement());
                    addEntry(col1, prefabs.presetDaytimeSpawnRange.cloneNode(true), new bindToggleableUnsignedFloat(preset.daytimeSpawnProbabilityRange));
                    addEntry(col1, prefabs.presetDaytime.cloneNode(true), new UniqueRarityBoundList(preset.daytimeEnemies, preset.availableDaytimeEnemies, EnemyType.bind).getElement());

                    col2.append(prefabs.presetTitleDungeons.cloneNode(true), document.createElement("br"));
                    addEntry(col2, prefabs.presetDungeonsMapSize.cloneNode(true), new bindToggleableUnsignedFloat(preset.mapSizeMultiplier));
                    addEntry(col2, prefabs.presetDungeons.cloneNode(true), new UniqueRarityBoundList(preset.dungeonFlows, preset.availableFlows, DungeonFlowType.bind).getElement());

                    col2.append(prefabs.presetTitleTraps.cloneNode(true), document.createElement("br"));
                    addEntry(col2, prefabs.presetTraps.cloneNode(true), new UniqueSelectBoundList(preset.traps, preset.availableTraps, TrapType.bind).getElement());

                    col2.append(prefabs.presetTitlePrices.cloneNode(true), document.createElement("br"));
                    addEntry(col2, prefabs.presetPrices.cloneNode(true), new UniqueSelectBoundList(preset.price, preset.availablePrices, PriceType.bind).getElement());

                    const gridBox = document.createElement("div");
                    gridBox.classList.add("grid");
                    gridBox.append(col1, col2);
                    container.appendChild(gridBox);

                    return container;
                }
            }

            
            class Configuration {
                constructor(data) {
                    this.defaults = data.defaults;
                    this.enemies = this.#generateEnemyTypes();
                    this.items = this.#generateItemTypes();
                    this.dungeonFlows = this.#generateDungeonFlows();
                    this.traps = this.#generateTrapTypes();
                    this.prices = this.#generatePrices();
                    this.levels = data.levels ? data.levels : {};
                    this.presets = data.presets ? data.presets : {};

                    this.generatePresets();
                    this.updatePresets();
                }

                getNewId() {
                    let id = null;
                    do {
                        id = "preset-" + Math.random().toString(16).slice(2)
                    } while (this.presets[id]);
                    return id;
                }

                generatePresets() {
                    for (const [levelId, levelInfo] of Object.entries(this.defaults.levels)) {
                        // Make sure every level has a valid preset linked to it
                        if (!this.levels[levelId]) {
                            console.log(`No preset detected for level ${levelId}, setting to ${levelId}`);
                            this.levels[levelId] = levelId;
                        } else if (!this.presets[this.levels[levelId]]) {
                            console.warn(`Preset ${this.levels[levelId]} for level ${levelId} does not exist, setting to ${levelId}`);
                            this.levels[levelId] = levelId;
                        }

                        // Don't generate a default preset for this level if one already exists
                        if (this.presets[levelId]) {
                            continue;
                        }

                        console.log(`No preset found with the id ${levelId}, creating`);

                        const preset = new Preset();
                        preset.id = levelId;
                        preset.name = (levelInfo.planet_name == null || levelInfo.planet_name === "") ? levelId : levelInfo.planet_name;
                        preset.mapSizeMultiplier.value = levelInfo.factory_size_multiplier
                        preset.scrapAmountMultiplier.value = this.defaults.scrap_amount_multiplier;
                        preset.scrapValueMultiplier.value = this.defaults.scrap_value_multiplier;
                        preset.minScrap.value = Math.min(levelInfo.min_scrap, levelInfo.max_scrap);
                        preset.maxScrap.value = Math.max(levelInfo.min_scrap, levelInfo.max_scrap);
                        preset.scrap.value = generateRaritiesFor(this.items, levelInfo.scrap);

                        preset.maxPowerCount.value = levelInfo.max_power_count;
                        preset.spawnCurve.value = structuredClone(levelInfo.enemy_spawn_curve);
                        preset.spawnProbabilityRange.value = levelInfo.enemy_spawn_probability_range;
                        preset.enemies.value = generateRaritiesFor(this.enemies, levelInfo.enemies);

                        preset.maxDaytimePowerCount.value = levelInfo.max_daytime_power_count;
                        preset.daytimeSpawnCurve.value = structuredClone(levelInfo.daytime_enemy_spawn_curve);
                        preset.daytimeSpawnProbabilityRange.value = levelInfo.daytime_enemy_spawn_probability_range;
                        preset.daytimeEnemies.value = generateRaritiesFor(this.enemies, levelInfo.daytime_enemies);

                        preset.maxOutsidePowerCount.value = levelInfo.max_outside_power_count;
                        preset.outsideSpawnCurve.value = structuredClone(levelInfo.outside_enemy_spawn_curve);
                        preset.outsideEnemies.value = generateRaritiesFor(this.enemies, levelInfo.outside_enemies);

                        preset.dungeonFlows.value = this.#generateDungeonFlowsFor(levelInfo.dungeon_flows);

                        preset.traps.value = this.#generateTrapsFor(levelInfo.spawnable_map_objects);

                        this.presets[preset.id] = preset;
                    }
                }

                updatePresets() {
                    for (const [id, preset] of Object.entries(this.presets)) {
                        this.updatePresetOptions(preset);

                        this.#removeUnknownId(preset.availableItems, preset.scrap.value);
                        this.#removeUnknownId(preset.availableEnemies, preset.enemies.value);
                        this.#removeUnknownId(preset.availableDaytimeEnemies, preset.daytimeEnemies.value);
                        this.#removeUnknownId(preset.availableOutsideEnemies, preset.outsideEnemies.value);
                        this.#removeUnknownId(preset.availableFlows, preset.dungeonFlows.value);
                        this.#removeUnknownId(preset.availableTraps, preset.traps.value);
                        this.#removeUnknownId(preset.availablePrices, preset.price.value);
                    }

                    for (const id of Object.keys(this.levels)) {
                        if (!this.defaults.levels[id]) {
                            console.log(`Found old level ${id}, removing`);
                            delete this.levels[id];
                        }
                    }
                }

                updatePresetOptions(preset) {
                    preset.availableItems = structuredClone(this.items);
                    preset.availableEnemies = structuredClone(this.enemies);
                    preset.availableDaytimeEnemies = structuredClone(this.enemies);
                    for (const val of Object.values(preset.availableDaytimeEnemies)) {
                        val.hasSpawnFalloff = false;
                    }
                    if (preset.daytimeEnemies.value) {
                        for (const val of Object.values(preset.daytimeEnemies.value)) {
                            val.hasSpawnFalloff = false;
                        }
                    }
                    preset.availableOutsideEnemies = structuredClone(this.enemies);
                    preset.availableFlows = structuredClone(this.dungeonFlows);
                    preset.availableTraps = structuredClone(this.traps);
                    preset.availablePrices = structuredClone(this.prices);
                }

                #removeUnknownId(options, list) {
                    let i = list?.length;
                    while (i--) {
                        if (!options[list[i].id]) {
                            list.splice(i, 1);
                        }
                    }
                }

                #generateTrapsFor(trapValues) {
                    const types = [];
                    for (const [id, type] of Object.entries(this.traps)) {
                        const copy = structuredClone(type);

                        copy.spawnCurve.value = trapValues[id];

                        types.push(copy);
                    }
                    return types;
                }

                #generateDungeonFlowsFor(flows) {
                    const types = generateRaritiesFor(this.dungeonFlows, flows);

                    for (const type of types) {
                        type.factorySizeMultiplier.value = this.defaults.map_size_multiplier;
                    }
                    return types;
                }

                #generateEnemyTypes() {
                    let types = {};
                    for (const [id, type] of Object.entries(this.defaults.enemies)) {
                        let jsType = new EnemyType();

                        jsType.maxEnemyCount.value = type.max_enemy_count;
                        jsType.powerLevel.value = type.power_level;
                        jsType.spawnChanceCurve.value = type.spawn_chance_curve;
                        jsType.stunTimeMultiplier.value = type.stun_time_multiplier;
                        jsType.doorSpeedMultiplier.value = type.door_speed_multiplier;
                        jsType.stunGameDifficultyMultiplier.value = type.stun_game_difficulty_multiplier;
                        jsType.stunnable.value = type.stunnable;
                        jsType.killable.value = type.killable;
                        jsType.enemyHp.value = type.enemy_hp;
                        jsType.spawnFalloffCurve.value = type.spawn_falloff_curve;
                        jsType.useSpawnFalloff.value = type.use_spawn_falloff;
                        jsType.name = type.name || id;
                        jsType.id = id;

                        types[id] = jsType;
                    }
                    return types;
                }

                #generateItemTypes() {
                    let types = {};
                    for (const [id, type] of Object.entries(this.defaults.items)) {
                        let jsType = new ItemType();

                        jsType.weight.value = type.weight;
                        jsType.minValue.value = type.min_value;
                        jsType.maxValue.value = type.max_value;
                        jsType.conductive.value = type.conductive;
                        jsType.scrap = type.scrap;
                        jsType.name = type.name;
                        jsType.id = id;

                        types[id] = jsType;
                    }
                    return types;
                }

                #generateDungeonFlows() {
                    let types = {};
                    for (const flow of this.defaults.dungeon_flows) {
                        let jsType = new DungeonFlowType();

                        jsType.name = flow;
                        jsType.id = flow;

                        types[flow] = jsType;
                    }
                    return types;
                }

                #generateTrapTypes() {
                    let types = {};
                    for (const [id, type] of Object.entries(this.defaults.traps)) {
                        let jsType = new TrapType();

                        jsType.spawnFacingAwayFromWall = type.spawn_facing_away_from_wall;
                        jsType.name = type.name || id;
                        jsType.description = type.description || "";
                        jsType.id = id;

                        types[id] = jsType;
                    }
                    return types;
                }

                #generatePrices() {
                    let prices = {};
                    for (const [id, level] of Object.entries(this.defaults.levels)) {
                        let jsType = new PriceType();

                        jsType.price.value = level.price;
                        jsType.name = (level.planet_name == null || level.planet_name === "") ? id : level.planet_name;
                        jsType.id = id;

                        prices[id] = jsType;
                    }
                    return prices;
                }
            }

            class PresetMenu {
                constructor(configuration) {
                    this.configuration = configuration;
                }

                static #bindEditor(menu) {
                    const col1 = document.createElement("span");
                    col1.style.gridColumn = "1/2";
                    col1.style.padding = "4px";
                    const col2 = document.createElement("span");
                    col2.style.gridColumn = "2/3";
                    col2.style.padding = "4px";

                    const levelInputs = {};

                    // Set up the levels section first
                    col2.append(prefabs.presetMenuBindEditorLevels.cloneNode(true), document.createElement("br"));
                    for (const [id, preset] of Object.entries(menu.configuration.levels)) {
                        const presetInput = document.createElement("input");
                        presetInput.type = "text";
                        presetInput.readOnly = true;
                        presetInput.placeholder = "No preset";

                        if (preset) {
                            const realPreset = menu.configuration.presets[preset];
                            if (realPreset.name) {
                                presetInput.value = realPreset.name;
                            } else {
                                presetInput.value = realPreset.id;
                            }
                        }
                        presetInput.addEventListener("dragover", ev => {
                            ev.preventDefault();
                            ev.dataTransfer.dropEffect = "link";
                        });
                        presetInput.addEventListener("drop", ev => {
                            ev.preventDefault();
                            ev.dataTransfer.dropEffect = "link";

                            const presetId = ev.dataTransfer.getData("text/plain");
                            const realPreset = menu.configuration.presets[presetId];
                            if (realPreset) {
                                menu.configuration.levels[id] = presetId;
                                presetInput.value = realPreset.name || presetId;
                            }
                        });

                        levelInputs[id] = presetInput;

                        addEntry(col2, format(id), presetInput);
                    }

                    menu.presetEntryContainer = col1;
                    col1.append(prefabs.presetMenuBindEditorPresets.cloneNode(true), document.createElement("br"));
                    const blankPreset = document.createElement("button");
                    blankPreset.textContent = "Add preset";
                    blankPreset.addEventListener("click", () => {
                        const preset = new Preset();

                        const id = menu.configuration.getNewId();
                        preset.id = id;

                        // Add the preset
                        menu.configuration.updatePresetOptions(preset);
                        menu.configuration.presets[id] = preset;
                        menu.presetList.appendChild(PresetMenu.#bindSidebarOption(menu, preset));

                        col1.appendChild(PresetMenu.#bindPresetNameEntry(menu, preset, levelInputs));
                    });
                    col1.append(blankPreset, document.createElement("br"));
                    for (const [id, preset] of Object.entries(menu.configuration.presets)) {
                        col1.appendChild(PresetMenu.#bindPresetNameEntry(menu, preset, levelInputs));
                    }

                    const gridBox = document.createElement("div");
                    gridBox.classList.add("grid");
                    gridBox.append(col1, col2);

                    const container = prefabs.container.cloneNode(true);
                    container.appendChild(gridBox);


                    return container;
                }

                static #bindPresetNameEntry(menu, preset, levelInputs) {
                    const id = preset.id;
                    const nameInput = document.createElement("input");
                    nameInput.type = "text";
                    nameInput.placeholder = id;
                    nameInput.value = preset.name;
                    nameInput.addEventListener("change", e => {
                        preset.name = nameInput.value;

                        if (menu.sidebarReferences[id]) {
                            // Fallback to id if the preset name is empty for some reason
                            if (preset.name) {
                                menu.sidebarReferences[id].textContent = preset.name;
                            } else {
                                menu.sidebarReferences[id].textContent = preset.id;
                            }
                        }

                        for (const [levelId, presetId] of Object.entries(menu.configuration.levels)) {
                            if (presetId === id) {
                                levelInputs[levelId].value = preset.name;
                            }
                        }
                    });

                    const copyButton = document.createElement("button");
                    copyButton.textContent = "Copy";
                    copyButton.addEventListener("click", () => {
                        const copy = structuredClone(preset);
                        copy.id = menu.configuration.getNewId();
                        copy.name = preset.name + "(copy)";

                        // Add the preset
                        menu.configuration.presets[copy.id] = copy;
                        menu.presetList.appendChild(PresetMenu.#bindSidebarOption(menu, copy));
                        menu.presetEntryContainer.appendChild(PresetMenu.#bindPresetNameEntry(menu, copy, levelInputs));
                    });

                    const presetNameSpan = document.createElement("span");
                    
                    let clicked = false;
                    const deleteButton = document.createElement("button");
                    deleteButton.textContent = "Delete";
                    deleteButton.addEventListener("focusout", () => {
                        clicked = false;
                        deleteButton.style.color = "";
                    });
                    deleteButton.addEventListener("click", () => {
                        if (clicked) {
                            menu.sidebarSpans[id].remove();
                            presetNameSpan.remove();
                            delete menu.sidebarSpans[id];
                            delete menu.configuration.presets[id];
                            for (const [levelId, presetId] of Object.entries(menu.configuration.levels)) {
                                if (presetId === id) {
                                    // Set the level preset to undefined
                                    menu.configuration.levels[levelId] = undefined;
                                    levelInputs[levelId].value = "";
                                }
                            }

                            for (const preset of Object.values(menu.configuration.presets)) {
                                if (preset.parent === id) {
                                    preset.parent = undefined;
                                }
                            }
                        } else {
                            clicked = true;
                            deleteButton.style.color = "red";
                        }
                    });

                    presetNameSpan.append(nameInput, copyButton, deleteButton, document.createElement("br"));
                    return presetNameSpan;
                }

                static bind(menu) {
                    menu.sidebarReferences = {};
                    menu.sidebarSpans = {};

                    const subcontainer = document.createElement("div");
                    subcontainer.classList.add("invis-container");

                    const presetTitle = document.createElement("b");
                    presetTitle.textContent = "Presets";
                    const presetButton = document.createElement("button");
                    presetButton.style.background = "none";
                    presetButton.style.border = "none";
                    presetButton.appendChild(presetTitle);
                    const presetEl = document.createElement("span");
                    presetEl.classList.add("preset");
                    presetEl.appendChild(presetButton);
                    presetEl.onclick = () => {
                        removeChildren(subcontainer);

                        if (menu.selected) {
                            menu.selected.style.backgroundColor = "";
                            delete menu.selected;
                        }

                        subcontainer.appendChild(PresetMenu.#bindEditor(menu));
                    };

                    const presetList = prefabs.container.cloneNode(true);
                    presetList.append(presetEl, document.createElement("br"));
                    for (const [id, preset] of Object.entries(menu.configuration.presets)) {
                        presetList.appendChild(PresetMenu.#bindSidebarOption(menu, preset));
                    }

                    menu.presetList = presetList;
                    menu.subcontainer = subcontainer;

                    const container = document.createElement("div");
                    container.append(presetList, subcontainer);

                    return container;
                }

                static #bindSidebarOption(menu, preset) {
                    // Use the preset name, but if it is empty, then use the preset id
                    const button = document.createElement("button");
                    button.style.background = "none";
                    button.style.border = "none";
                    button.draggable = true;
                    button.textContent = preset.name || preset.id;
                    const presetSpan = document.createElement("span");
                    presetSpan.style.textAlign = "right";
                    presetSpan.appendChild(button);
                    const mainSpan = document.createElement("span");
                    mainSpan.classList.add("preset");
                    mainSpan.draggable = true;
                    mainSpan.append(">", presetSpan);
                    mainSpan.addEventListener("dragstart", ev => {
                        ev.dataTransfer.setData("text/plain", preset.id);
                    });

                    const span = document.createElement("span");
                    span.append(mainSpan, document.createElement("br"));
                    span.onclick = () => {
                        if (menu.selected != mainSpan) {
                            removeChildren(menu.subcontainer);

                            if (menu.selected) {
                                menu.selected.style.backgroundColor = "";
                            }
                            menu.selected = mainSpan;
                            mainSpan.style.backgroundColor = "lightgray";

                            menu.subcontainer.appendChild(Preset.bind(preset, menu.configuration.presets));
                        }
                    };

                    mainSpan.addEventListener("dragover", ev => {
                        ev.preventDefault();
                        ev.dataTransfer.dropEffect = "move";
                    });
                    mainSpan.addEventListener("drop", ev => {
                        ev.preventDefault();
                        ev.dataTransfer.dropEffect = "move";

                        const presetId = ev.dataTransfer.getData("text/plain");
                        if (presetId !== preset.id && menu.sidebarSpans[presetId]) {
                            // Move around the presets
                            const keys = Object.keys(menu.configuration.presets);
                            const oldPos = keys.indexOf(presetId);
                            const newPos = keys.indexOf(preset.id);

                            const entries = Object.entries(menu.configuration.presets);
                            const entry = entries.splice(oldPos, 1)[0];
                            entries.splice(newPos, 0, entry);
                            menu.configuration.presets = Object.fromEntries(entries);

                            menu.presetList.insertBefore(menu.sidebarSpans[presetId], oldPos < newPos ? span.nextSibling : span);
                        }
                    });

                    menu.sidebarReferences[preset.id] = button;
                    menu.sidebarSpans[preset.id] = span;

                    return span;
                }
            }

            function tooltip(element, tooltip) {
                let tipbox = document.createElement("span");
                tipbox.classList.add("tooltiptext");
                if (typeof tooltip === "string" || tooltip instanceof String) {
                    tipbox.textContent = tooltip;
                } else {
                    tipbox.appendChild(tooltip);
                }

                let title = element;
                if (typeof element === "string" || element instanceof String) {
                    title = document.createElement("span");
                    title.textContent = element;
                }
                title.classList.add("tooltip");
                title.appendChild(tipbox);
                return title;
            }

            function addEntry(block, title, element) {
                const titleSpan = document.createElement("span");
                titleSpan.classList.add("title");
                if (typeof title === "string" || title instanceof String) {
                    titleSpan.appendChild(document.createTextNode(title));
                } else {
                    titleSpan.appendChild(title);
                }
                const span = document.createElement("span");
                span.append(titleSpan, element, document.createElement("br"));
                block.appendChild(span);
            }

            // TODO List:
            // = HIGH PRIORITY
            // - Add copy paste functionality, needs to be able to specify which one
            // = Medium Priority
            // - Make the select bound list a dictionary
            // - Make addElement faster
            // - Make lists faster
            // - Make addToSelect faster
            // = low priority
            // - Add styling options, such as a more lethal company-esque UI
            // - Design the UI
            // - Separate items into store vs scrap, in the select dropdown
            // - Allow sorting of entries in unique bound lists
            // - Allow subdirectories for presets
            // - Use locale keys for descriptions, spoilers, titles, etc
            // - Add custom tooltip modification for list entries
            // - Check for XSS vulnerabilities

            function readFile(file) {
                let reader = new FileReader();
                reader.onload = file => {
                    try {
                        defaultData = JSON.parse(reader.result);

                        loadData(defaultData);
                    } catch (e) {
                        alert("The file provided is not a JSON file");
                    }
                };
                reader.readAsText(file);
            }

            function loadData(data) {
                if (data["defaults"]) {
                    console.log("Loading input data:");
                    console.log(data);

                    const configuration = new Configuration(data);

                    createInterfaceFor(configuration);
                } else {
                    alert("Invalid data");
                }
            }

            function createInterfaceFor(configuration) {
                removeChildren(document.body);

                // Keep a backup to compare for any changes
                const configurationBackup = structuredClone(configuration);
                const leaveEventListener = (e) => {
                    if (JSON.stringify(configuration) !== JSON.stringify(configurationBackup)) {
                        console.log("Tried to exit with unsaved information");
                        e.preventDefault();

                    }

                    localStorage.setItem("saved", JSON.stringify(exportConfiguration(configuration)));
                };
                window.addEventListener("beforeunload", leaveEventListener);

                const menu = new PresetMenu(configuration);

                const downloadButton = document.createElement("button");
                downloadButton.textContent = "Download";
                downloadButton.addEventListener("click", () => {
                    console.log("Saving configuration via the download button");
                    downloadConfiguration(configuration, "presets.json");
                });

                document.addEventListener("keydown", e => {
                    if (e.ctrlKey && e.key === 's') {
                        console.log("Saving configuration via ctrl+s")
                        e.preventDefault();
                        downloadConfiguration(configuration, "presets.json");
                    }
                });

                // Add a reset button to go back to the main screen
                const resetButton = document.createElement("button");
                resetButton.textContent = "Edit another file";
                resetButton.addEventListener("click", () => {
                    if (confirm("Any information you have currently will be deleted. Are you sure you want to continue?")) {
                        localStorage.removeItem("saved");
                        window.removeEventListener("beforeunload", leaveEventListener);
                        initialize();
                    }
                });

                const outer = document.createElement("div");
                outer.append(resetButton, downloadButton, document.createTextNode("or press Ctrl+S to save"), PresetMenu.bind(menu));

                document.body.appendChild(outer);
            }

            function exportConfiguration(configuration) {
                const copy = structuredClone(configuration.presets);
                for (const val of Object.values(copy)) {
                    // Trim useless portions
                    delete val.availableItems;
                    delete val.availableEnemies;
                    delete val.availableDaytimeEnemies;
                    delete val.availableOutsideEnemies;
                    delete val.availableFlows;
                    delete val.availableTraps;
                    delete val.availablePrices;
                }

                // Follow the LQ json format
                // defaults: <default data>
                // presets: <presets>
                // levels: <levels>
                const exports = {
                    defaults: configuration.defaults,
                    presets: copy,
                    levels: configuration.levels
                };

                return exports;
            }

            function downloadConfiguration(configuration, filename) {
                const exports = exportConfiguration(configuration);

                console.log("Exporting data:");
                console.log(exports);

                download(filename, JSON.stringify(exports));
            }

            function removeChildren(node) {
                while (node.firstChild) {
                    node.removeChild(node.lastChild);
                }
            }

            function generateRaritiesFor(options, rarities) {
                const types = [];
                for (const [id, type] of Object.entries(options)) {
                    if (rarities[id]) {
                        const copy = structuredClone(type);
                        copy.rarity.value = rarities[id];
                        // Set it to true for now
                        copy.rarity.set = true;
                        types.push(copy);
                    }
                }
                return types;
            }

            function bindToggleableInt(obj, width = "") {
                const input = document.createElement("input");
                input.type = "number";
                input.step = 1;
                input.style.width = width;
                obj.placeholder && (input.placeholder = obj.placeholder);
                return new ToggleableBoundElement(input, obj).getElement();
            }

            function bindToggleableUnsignedInt(obj, width = "") {
                const input = document.createElement("input");
                input.type = "number";
                input.min = 0;
                input.step = 1;
                input.style.width = width;
                obj.placeholder && (input.placeholder = obj.placeholder);
                return new ToggleableBoundElement(input, obj).getElement();
            }

            function bindInt(obj, width = "") {
                const input = document.createElement("input");
                input.type = "number";
                input.step = 1;
                input.style.width = width;
                obj.placeholder && (input.placeholder = obj.placeholder);
                return new BoundElement(input, obj).getElement();
            }

            function bindToggleableFloat(obj, width = "") {
                const input = document.createElement("input");
                input.type = "number";
                input.style.width = width;
                obj.placeholder && (input.placeholder = obj.placeholder);
                return new ToggleableBoundElement(input, obj).getElement();
            }

            function bindToggleableUnsignedFloat(obj, width = "") {
                const input = document.createElement("input");
                input.type = "number";
                input.min = 0;
                input.style.width = width;
                obj.placeholder && (input.placeholder = obj.placeholder);
                return new ToggleableBoundElement(input, obj).getElement();
            }

            function bindFloat(obj, width = "") {
                const input = document.createElement("input");
                input.type = "number";
                input.style.width = width;
                obj.placeholder && (input.placeholder = obj.placeholder);
                return new BoundElement(input, obj).getElement();
            }

            function bindToggleableBool(obj) {
                const select = document.createElement("select");
                select.add(new Option("True", "true"));
                select.add(new Option("False", "false"));
                return new ToggleableBoundElement(select, obj).getElement();
            }

            function bindBool(obj) {
                const select = document.createElement("select");
                select.add(new Option("", null, true));
                select.add(new Option("True", "true"));
                select.add(new Option("False", "false"));
                return new BoundElement(select, obj).getElement();
            }

            function format(str) {
                return str.replace("&", "&amp;")
                        .replace(">", "&gt;")
                        .replace("<", "&lt;");
            }

            // Insertion sort
            function addToSelect(sel, el) {
                let index = 0;
                for (; index < sel.options.length && el.text > sel.options[index].text; index++);
                if (index == sel.options.length) {
                    sel.options.add(el);
                } else {
                    sel.options.add(el, sel.options[index]);
                }
            }

            function download(filename, text) {
                const element = document.createElement('a');
                element.setAttribute('href', 'data:text/json;charset=utf-8,' + encodeURIComponent(text));
                element.setAttribute('download', filename);
                element.click();
            }

            // Generate the drop zone as soon as the body is done loading
            // Or, load an existing file from local storage
            function initialize() {
                const saved = localStorage.getItem("saved");
                if (saved) {
                    console.log("Found saved data");
                    loadData(JSON.parse(saved));
                } else {
                    removeChildren(document.body);
                    console.log("No save data found");
                    const zone = document.createElement("div");
                    zone.classList.add("zone");
                    zone.addEventListener("click", () => {
                        const input = document.createElement("input");
                        input.type = "file";
                        input.accept = ".json";
                        input.addEventListener("change", event => {
                            let file = event.target.files[0];
                            if (file) {
                                readFile(file);
                            }
                        });

                        input.click();
                    });
                    zone.addEventListener("drop", event => {
                        event.preventDefault();

                        let file = null;
                        if (event.dataTransfer.items) {
                            const item = event.dataTransfer.items[0];
                            if (item.kind === "file") {
                                file = item.getAsFile();
                            }
                        } else {
                            file = event.dataTransfer.files[0];
                        }

                        if (file) {
                            readFile(file);
                        }
                    });
                    zone.addEventListener("dragover", event => {
                        event.preventDefault();
                    });

                    const textSpan = document.createElement("span");
                    textSpan.append("Drag & drop a file to edit", document.createElement("br"), "Or click to upload");
                    zone.appendChild(textSpan);

                    document.body.appendChild(zone);
                }
            }
        </script>
        <style>
            div.editor {
                display: block;
            }
            div.grid {
                display: inline-grid;
            }
            div.container {
                vertical-align: text-top;
                outline-style: solid;
                border-radius: 2px;
                padding: 5px;
                margin: 5px;
                display: inline-block;
            }
            div.invis-container {
                vertical-align: text-top;
                display: inline-block;
            }
            div.zone {
                display: flex;
                position: fixed;
                width: 100%;
                height: 100%;
                bottom: 0;
                right: 0;
                justify-content: center;
                align-items: center;
            }
            span.title {
                display: inline-block;
                margin-top: 5px;
                width: 200px;
                text-align: right;
            }
            span.preset {
                display: inline-block;
                padding: 2px;
                min-width: 150px;
            }
            span.preset:hover {
                background-color: #FE6C07;
            }
            .tooltip {
                position: relative;
                display: inline-block;
            }
            .tooltiptext {
                opacity: 0;
                padding: 5px;
                border-radius: 2px;
                outline-style: solid;
                background-color: white;
                width: max-content;
                max-width: 500px;
                display: block;
                text-align: left;
                pointer-events: none;
                position: absolute;
                z-index: 1;
            }
            .tooltip:hover .tooltiptext{
                opacity: 1;
            }
        </style>
    </head>
    <body onload="initialize()">
    </body>
</html>